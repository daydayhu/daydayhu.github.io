<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[层叠上下文]]></title>
      <url>http://www.skyshu.com/2018/08/07/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      <content type="html"><![CDATA[<p><strong>层叠上下文</strong>: HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</p>
<p><strong>层叠上下文形成条件</strong>: </p>
<ul>
<li>根元素 (HTML),</li>
<li>z-index 值不为 “auto”的 绝对/相对定位，</li>
<li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素display: flex|inline-flex，</li>
<li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li>
<li>transform 属性值不为 “none”的元素，</li>
<li>mix-blend-mode 属性值不为 “normal”的元素，</li>
<li>filter值不为“none”的元素，</li>
<li>perspective值不为“none”的元素，</li>
<li>isolation 属性被设置为 “isolate”的元素，</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）</li>
<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>
</ul>
<p>在层叠上下文中，其子元素同样也按照上面解释的规则进行层叠。 特别值得一提的是，其子元素的 z-index 值只在父级层叠上下文中有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。</p>
<p>总结：</p>
<ul>
<li>给一个 HTML 元素定位和 z-index 赋值创建一个层叠上下文，（opacity 值不为 1 的也是相同）。</li>
<li>层叠上下文可以包含在其他层叠上下文中，并且一起创建一个有层级的层叠上下文。</li>
<li>每个层叠上下文完全独立于它的兄弟元素：当处理层叠时只考虑子元素。</li>
<li>每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会 在父层叠上下文中 按顺序进行层叠。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[块格式化上下文（Block Formatting Context，BFC）]]></title>
      <url>http://www.skyshu.com/2018/08/07/BFC/</url>
      <content type="html"><![CDATA[<p><strong>块格式化上下文</strong>：是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p><strong>块格式化上下文生成条件</strong></p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）</li>
<li>overflow 值不为 visible 的块元素</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content或 strict 的元素</li>
<li>弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li>
<li>网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>
</ul>
<p>创建了块格式化上下文的元素中的所有内容都会被包含到该BFC中。</p>
<p>块格式化上下文对浮动定位与清除浮动都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Function.prototype 的常用属性和方法解读]]></title>
      <url>http://www.skyshu.com/2018/08/06/Function_prototype/</url>
      <content type="html"><![CDATA[<p>此处仅对常用的Funtion原型属性/方法进行分析。</p>
<p><strong>属性</strong></p>
<p><code>Function.arguments</code>:以数组形式获取传入函数的所有参数。<br>补充说明：已定义参数、未定义参数(rest)与arguments关系。相关代码如下：</p>
<pre><code>function foo(a, b, ...rest) {
  console.log(&apos;a = &apos;+ a);
  console.log(&apos;b = &apos;+ a);
  console.log(rest);
  console.log(arguments);
}
foo(1,2,3,4,5);

// result
// a = 1
// b = 2
// Array [3,4,5]
// Array [1,2,3,4,5] 省略内置方法
</code></pre><p><code>Function.prototype.constructor</code>：指定创建对象原型的函数。基于此，亦可用来判断数据类型。</p>
<p><strong>方法</strong></p>
<p><code>Function.prototype.apply()</code>: 在一个对象的上下文中应用另一个对象的方法；参数能够以数组形式传入(参数指调用当前方法，可传入的实参)。</p>
<p><code>Function.prototype.call()</code>: 在一个对象的上下文中应用另一个对象的方法；参数能够以列表形式传入(参数指调用当前方法，可传入的实参)。</p>
<p><strong><a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="external">call()与apply()的实现原理</a></strong></p>
<p>二者简而言之的目的，都是为了使用其他对象的方法。</p>
<p>可分为3个步骤</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<p>以call()为例，实现代码如下：</p>
<pre><code>Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }

    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);

    delete context.fn
    return result;
}

// 测试一下
var value = 2;
var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.call(null); // 2

console.log(bar.call2(obj, &apos;kevin&apos;, 18));
// 1
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>更改方法/函数内部this指向，本质上来说，是给需要使用该方法的对象，临时新增了该方法，并没有改变该方法的原始所属对象。</p>
<p><code>Function.prototype.bind</code>: bind()方法会创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this,传入 bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="external"><strong>bind()的实现原理</strong></a></p>
<p>bind()函数的两个特点:</p>
<ol>
<li>返回一个函数</li>
<li>可以传入参数</li>
</ol>
<p>实现代码如下：</p>
<pre><code>Function.prototype.bind2 = function (context) {

if (typeof this !== &quot;function&quot;) {
  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
}

var self = this;
var args = Array.prototype.slice.call(arguments, 1);

var fNOP = function () {};

var fBound = function () {
    var bindArgs = Array.prototype.slice.call(arguments);
    return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
}

fNOP.prototype = this.prototype;
fBound.prototype = new fNOP();
return fBound;
}
</code></pre><p>apply call bind三者比较：</p>
<ol>
<li><p>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的。</p>
</li>
<li><p>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文。</p>
</li>
<li><p>apply 、 call 、bind 三者都可以利用后续参数传参。</p>
</li>
<li><p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。</p>
</li>
</ol>
<p>代码演示如下：</p>
<pre><code>var obj = {
    x: 81,
};
var foo = {
    getX: function() {
        return this.x;
    }
}
console.log(foo.getX.bind(obj)());  //81
console.log(foo.getX.call(obj));    //81
console.log(foo.getX.apply(obj));   //81

/*
    区别在于, 使用apply()/call(), 改变上下文环境之后,
    会立即执行函数; 而使用bind(), 并非立即执行, 而是回调执行
*/ 
</code></pre><p><code>Function.prototype.toString</code>: 返回一个表示当前函数源代码的字符串。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js之深拷贝与浅拷贝]]></title>
      <url>http://www.skyshu.com/2018/08/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p><strong>基本概念</strong></p>
<p>从指针的角度出发，浅拷贝只是增加了一个指针，指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存。</p>
<p><strong>浅拷贝与深拷贝解读</strong></p>
<p>js包括<strong>基本数据类型</strong>与<strong>引用数据类型</strong>。基本数据类型即 number、string、boolean、null、undefined五类。引用数据类型即 Object、Array、function。</p>
<p>从堆栈关系来说，二者的主要区别在于数据存储的位置不同，基础数据类型值存储在栈区，而引用数据类型值存储在堆区，其地址存储在栈区。</p>
<p>基础数据类型赋值时，会在栈区开辟一块新的内存，将值存储在栈区，以确保赋值与被赋值变量二者的独立性。</p>
<p>引用数据类型赋值时，也会在栈区开辟一块新的内存，不过存储的是值所在的地址(指针)，而值所在的堆区保持不变。赋值与被赋值变量二者存储的地址指向的是同一块堆区内存。通过这种赋值方式，由于使用同一块堆区内存，只要一方的数据发生变化，另一方数据也会随之变化，也将这种赋值称作浅拷贝。若不想产生这种相互干扰，得让双方不共用同一块堆区内存，开辟一块新的堆区内存，以实现深拷贝。由此可以看出浅拷贝与深拷贝是针对引用数据类型进行的。</p>
<p><strong>如何实现深拷贝</strong></p>
<p><strong>1.递归</strong></p>
<p>通过层层递归，可将引用数据类型的赋值，转成基础数据类型的赋值，代码实现如下：</p>
<pre><code>var obj1 = {name:&apos;DDB&apos;,age:18,arr:[1,2,3,4]};
var obj2 = {};
function deepCloneByRecurve(primaryObj,copyObj) {
   var _copyObj = copyObj || {};
   for (var key in primaryObj){
     if(typeof primaryObj[key] === &apos;object&apos;){
       _copyObj[key] = (primaryObj[key].constructor === Array) ? []:{};
       deepCloneByRecurve(primaryObj[key],_copyObj[key]);
     }else {
       _copyObj[key] = primaryObj[key];
     }
   }
   return _copyObj;
}
obj2 = deepCloneByRecurve(obj1,obj2);
obj2.arr.push(5);
console.log(obj1.arr); // [1,2,3,4]
console.log(obj2.arr); // [1,2,3,4,5]
</code></pre><p><strong>2.json</strong></p>
<p>可利用JSON进行深拷贝，代码实现如下：  </p>
<pre><code>var obj1 = {name:&apos;DDB&apos;,age:18,arr:[1,2,3,4]};
var obj3 = {};
function deepCloneByJOSN(primaryObj) {
  return JSON.parse(JSON.stringify(primaryObj));
}
var obj3 = deepCloneByJOSN(obj1);
obj3.arr.push(6);
console.log(obj1.arr); // [1,2,3,4]
console.log(obj3.arr); // [1,2,3,4,6]
</code></pre><p>对于一般的需求是可以满足的，但是它有缺点。下例中，可以看到JSON复制会忽略掉值为undefined以及函数表达式。</p>
<pre><code>var obj = {
  a: 1,
  b: 2,
  c: undefined,
  sum: function() { return a + b; }
};
var obj2 = deepCloneByJOSN(obj);
console.log(obj2);  //Object {a: 1, b: 2}
</code></pre><p><strong>3.针对数组深拷贝的其他实现</strong></p>
<p>3.1 <strong>slice</strong>方法</p>
<p>slice() 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</p>
<p>实现代码如下：</p>
<pre><code>var arr = [1,2,3,4,5];
var arr2 = arr.slice(0);
arr2[2] = 5;
console.log(arr); // [1,2,3,4,5]
console.log(arr2); // [1,2,5,4,5]
</code></pre><p>3.2 <strong>concat</strong>方法</p>
<p>concat() 不会改变现有的数组，而仅仅会返回被连接数组的一个副本（新数组）。</p>
<p>实现代码如下：</p>
<pre><code>var arr = [1,2,3,4,5];
var arr2 = arr.concat();
arr2[2] = 5;
console.log(arr); // [1,2,3,4,5]
console.log(arr2); // [1,2,5,4,5]
</code></pre><p>3.3 ES6的扩展方法 <strong>Array.from / …</strong></p>
<p>1)  <strong>Array.from()</strong> 方法从一个类似数组或可迭代对象中创建一个新的数组实例。</p>
<p>代码实现如下：</p>
<pre><code>var arr1=[1,2,3];
var arr2=Array.from(arr1);
arr2.push(4);
console.log(arr1); // [1,2,3]
console.log(arr2); // [1,2,3,4]
</code></pre><p>2)  <strong>扩展运算符(…)</strong></p>
<p>扩展运算符(spread) 是3个点 (…)。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p>代码实现如下：</p>
<pre><code>var arr1=[1,2,3];
var arr2=[...arr1];
arr2.push(4);
console.log(arr1); // [1,2,3]
console.log(arr2); // [1,2,3,4]
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器探讨(—)]]></title>
      <url>http://www.skyshu.com/2018/08/03/brower/</url>
      <content type="html"><![CDATA[<p><strong>浏览器的主要功能</strong></p>
<p>浏览器的主要功能是通过从服务器请求并在浏览器窗口中显示它来显示您选择的Web资源。资源通常是HTML文档，但也可以是PDF，图像或其他类型的内容。用户使用<strong>URI</strong>（统一资源标识符）指定资源的位置。</p>
<p><strong>浏览器的高级结构</strong></p>
<p>1.<strong>用户界面</strong>：这包括地址栏，后退/前进按钮，书签菜单等。浏览器的每个部分都显示除了您看到所请求页面的窗口。</p>
<p>2.<strong>浏览器引擎</strong>：在UI和呈现引擎之间编组操作。</p>
<p>3.<strong>渲染引擎</strong>：负责显示请求的内容。例如，如果请求的内容是HTML，则呈现引擎解析HTML和CSS，并在屏幕上显示解析的内容。不同的浏览器使用不同的渲染引擎：<strong>Internet Explorer使用Trident，Firefox使用Gecko，Safari使用WebKit。Chrome和Opera（来自15版）使用Blink，一个WebKit的分支</strong>。</p>
<p>4.<strong>网络</strong>：用于网络调用，例如HTTP请求，在独立于平台的界面后面使用不同平台的不同实现。</p>
<p>5.<strong>UI后端</strong>：用于绘制组合框和窗口等基本小部件。此后端公开了一个非平台特定的通用接口。它下面使用操作系统用户界面方法。</p>
<p>6.<strong>JavaScript解释器</strong>：用于解析和执行JavaScript代码。</p>
<p>7.<strong>数据存储</strong>：这是一个持久层。浏览器可能需要在本地保存各种数据，例如cookie。浏览器还支持存储机制，例如localStorage，IndexedDB，WebSQL和FileSystem。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Object.defineProperty]]></title>
      <url>http://www.skyshu.com/2018/08/02/defineProperty/</url>
      <content type="html"><![CDATA[<h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty()</a></h1><hr>
<p><strong>作用</strong> 该方法会直接在一个对象上定义一个新属性, 或者修改一个对象的现有属性, 并返回这个对象。</p>
<p><strong>语法</strong> <code>Object.defineProperty(obj, prop, descriptor)</code></p>
<p><strong>参数</strong>  </p>
<p><code>obj</code>: 要在其上定义属性的对象。</p>
<p><code>prop</code>: 要定义或修改的属性的名称。</p>
<p><code>descriptor</code>: 将被定义或修改的属性描述符。</p>
<p><strong>属性描述符</strong> </p>
<p> 对象里目前存在的属性描述符有两种主要形式<strong>数据描述符</strong>和<strong>存取描述符</strong>。<strong>数据描述符</strong>是一个具有值的属性，该值可能是可写的，也可能不是可写的。<strong>存取描述符</strong>是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。</p>
<p><strong>数据描述符和存取描述符均具</strong>有以下可选键值：</p>
<p><code>configurable</code><br>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</p>
<p><code>enumerable</code> 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</p>
<p><strong>数据描述符同时具有以下可选键值</strong>:</p>
<p><code>value</code>  该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p>
<p><code>writable</code> 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p>
<p><strong>存取描述符同时具有以下可选键值</strong></p>
<p><code>get</code>  一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。</p>
<p><code>set</code>  一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。</p>
]]></content>
    </entry>
    
  
  
</search>

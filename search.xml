<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[webpack学习（—）]]></title>
      <url>http://www.skyshu.com/2018/11/19/webpack/</url>
      <content type="html"><![CDATA[<p><strong>1.概念：</strong><br>Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。本质上，webpack 是一个现代 JavaScript 应用程序的<strong>静态模块打包器</strong>(module bundler)。<strong>当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</strong></p>
<p><strong>2.四个核心：</strong></p>
<ul>
<li>入口(entry)</li>
<li>输出(output)</li>
<li>loader</li>
<li>插件(plugins)</li>
</ul>
<p><strong>入口(entry)</strong></p>
<p>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 <strong>bundles</strong> 的文件中。</p>
<p>可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。</p>
<p>在webpack.config.js文件中配置入口文件：</p>
<pre><code>module.exports = {
  entry: &apos;./path/to/my/entry/file.js&apos;
}
</code></pre><p><strong>出口(output)</strong></p>
<p>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：</p>
<p>在webpack.config.js文件中配置出口文件：</p>
<p>onst path = require(‘path’);</p>
<pre><code>module.exports = {
  entry: &apos;./path/to/my/entry/file.js&apos;,
  output: {
    path: path.resolve(__dirname, &apos;dist&apos;),
    filename: &apos;my-first-webpack.bundle.js&apos;
  }
};
</code></pre><p><strong>loader</strong></p>
<p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p>
<p>在更高层面，在 webpack 的配置中 loader 有两个目标：</p>
<p>test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。（目标文件）<br>use 属性，表示进行转换时，应该使用哪个 loader。（所使用加载器）</p>
<pre><code>在webpack.config.js文件中配置loader：

const path = require(&apos;path&apos;);

const config = {
  output: {
    filename: &apos;my-first-webpack.bundle.js&apos;
  },
  module: {
    rules: [
      { test: /\.txt$/, use: &apos;raw-loader&apos; }
    ]
  }
};

module.exports = config;
</code></pre><p>以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息：</p>
<blockquote>
<p>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。”</p>
</blockquote>
<p><strong>插件(plugins)</strong></p>
<p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p>
<p>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p>
<p>在webpack.config.js文件中配置plugins：</p>
<pre><code>const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); // 通过 npm 安装
const webpack = require(&apos;webpack&apos;); // 用于访问内置插件

const config = {
  module: {
    rules: [
      { test: /\.txt$/, use: &apos;raw-loader&apos; }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;})
  ]
};

module.exports = config;
</code></pre><p><strong>3.模式</strong></p>
<p>项目开发一般基于两种模式，<strong>开发者模式(development</strong>)和<strong>生产模式(production)</strong>，在webpack中可以通过设置mode 参数，启用相应模式下的 webpack 内置的优化。如下：</p>
<pre><code>module.exports = {
  mode: &apos;production&apos;
};
</code></pre><p><strong>4.demo实例</strong></p>
<p><a href="https://github.com/ruanyf/webpack-demos#demo01-entry-file-source" target="_blank" rel="external">demo</a> 来自阮一峰github提供，一共15个。</p>
<p><strong>demo01: 入口文件</strong></p>
<p>入口文件main.js:</p>
<pre><code>document.write(&apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;);
</code></pre><p>index.html文件：</p>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>webpack.config.js文件配置：</p>
<pre><code>module.exports = {
  entry: &apos;./main.js&apos;,
  output: {
    filename: &apos;bundle.js&apos;
  }
};
</code></pre><p>最终构建–出口文件bundle.js。运行webpack-dev-server/npm run dev(基于package.json文件)</p>
<pre><code>&quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --open&quot;,
    &quot;build&quot;: &quot;webpack -p&quot;
 },
</code></pre><p>执行完成，文档输入：Hello World。</p>
<p><strong>demo02: 多入口文件</strong></p>
<p>多入口文件是合法的，它通常被应用于<strong>一个多页应用程序</strong></p>
<p>入口文件1, main1.js:</p>
<pre><code>document.write(&apos;&lt;h1&gt;Hello World&lt;/h1&gt;&apos;);
</code></pre><p>入口文件2, main2.js:</p>
<pre><code>document.write(&apos;&lt;h1&gt;Hello Webpack&lt;/h1&gt;&apos;);
</code></pre><p>index.html文件：</p>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;script src=&quot;bundle1.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;bundle2.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>webpack.config.js文件配置：</p>
<pre><code>module.exports = {
  entry: {
    bundle1: &apos;./main1.js&apos;,
    bundle2: &apos;./main2.js&apos;
  },
  output: {
    filename: &apos;[name].js&apos;
  }
};
</code></pre><p>最终构建–多个出口文件bundle1.js、bundle2.js。<br>执行完成，文档输入：Hello World、Hello Webpack。</p>
<p><strong>demo03: Babel-loader</strong></p>
<p>loaders（加载器）是可以转换您的应用程序资源（更多信息）文件的一个预处理器，例如Babel-loader可以将JSX / ES6文件转换为JS文件。官方文档有一个完整的loaders（加载器） ）列表。</p>
<p>入口文件main.jsx，是一个JSX文件。</p>
<pre><code>const React = require(&apos;react&apos;);
const ReactDOM = require(&apos;react-dom&apos;);

ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.querySelector(&apos;#wrapper&apos;)
);
</code></pre><p>index.html文件：</p>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;div id=&quot;wrapper&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>webpack.config.js文件配置：</p>
<pre><code>module.exports = {
  entry: &apos;./main.jsx&apos;,
  output: {
    filename: &apos;bundle.js&apos;
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: &apos;babel-loader&apos;,
          options: {
            presets: [&apos;es2015&apos;, &apos;react&apos;]
          }
        }
      }
    ]
  }
};
</code></pre><p>上面的片段使用babel-loaderBabel的预设插件babel-preset-es2015和babel-preset-react来转换ES6和React。</p>
<p><strong>demo04： CSS-loader</strong></p>
<p>Webpack允许您将CSS包含在JS文件中，然后使用CSS-loader预处理CSS文件。</p>
<p>入口文件main.js:</p>
<pre><code>require(&apos;./app.css&apos;);
</code></pre><p>css样式文件app.css:</p>
<pre><code>body {
  background-color: blue;
}
</code></pre><p>index.html文件：</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello World&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>webpack.config.js文件配置：</p>
<pre><code>module.exports = {
  entry: &apos;./main.js&apos;,
  output: {
    filename: &apos;bundle.js&apos;
  },
  module: {
    rules:[
      {
        test: /\.css$/,
        use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ]
      },
    ]
  }
};
</code></pre><p>这里使用两个加载器来转换CSS文件。首先是CSS-loader读取CSS文件，另一个是Style-loader将<code>&lt;style&gt;</code>标签插入HTML页面。</p>
<p>执行完成，Webpack会将内部样式表插入其中index.html。</p>
<pre><code>&lt;head&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    body {
      background-color: blue;
    }
  &lt;/style&gt;
&lt;/head&gt;
</code></pre><p><strong>demo05: Image loader</strong></p>
<p>Webpack还可以在JS文件中包含图像。</p>
<p>入口文件main.js： </p>
<pre><code>var img1 = document.createElement(&quot;img&quot;);
img1.src = require(&quot;./small.png&quot;);
document.body.appendChild(img1);

var img2 = document.createElement(&quot;img&quot;);
img2.src = require(&quot;./big.png&quot;);
document.body.appendChild(img2);
</code></pre><p>index.html文件：</p>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>webpack.config.js文件配置：</p>
<pre><code>module.exports = {
  entry: &apos;./main.js&apos;,
  output: {
    filename: &apos;bundle.js&apos;
  },
  module: {
    rules:[
      {
        test: /\.(png|jpg)$/,
        use: [
          {
            loader: &apos;url-loader&apos;,
            options: {
              limit: 8192
            }
          }
        ]
      }
    ]
  }
};
</code></pre><p>url-loader将图像文件转换为<strong><img></strong>标记。如果图像大小小于8192字节，则将其转换为数据URL(base64); 否则，它将转换为普通的URL。</p>
<p>执行完成，结果如下：</p>
<pre><code>&lt;img src=&quot;data:image/png;base64,iVBOR...uQmCC&quot;&gt;
&lt;img src=&quot;4853ca667a2b8b8844eb2693ac1b2578.png&quot;&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML、XML、XHTML区别]]></title>
      <url>http://www.skyshu.com/2018/11/16/html_xml_xhtml%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>再说HTML、XML、XHTML区别之前，先了解一下其历史</p>
<p><strong>1.历史</strong></p>
<p>数据标记的需求起源于电子数据格式化。<strong>早期的电子数据格式化主要关注的是数据应该如何被显示而不是数据的文档结构和含义</strong>。Troff(UNIX下的文档资料排版、编辑和格式化程序)和TEX(一种电子排版系统)就是两种早期的格式化语言，在格式化打印文档方面取得了很多成果，但是缺少任何关于结构方面的功能。因此这些文档只局限于屏幕显示和硬拷贝打印。人们难以编写一个程序对这些文档中的信息进行查找、提取和前后对照，更不能方便地将一个文档中的数据重复用于不同的应用中。</p>
<p>　　<strong>通用编码(Generic Coding)使用描述性标签取代格式码</strong>，最终解决上述问题。最早认真研究该问题的是<strong>图形通信协会</strong>(Graphic Communications Association，GCA)。<strong>在20世纪60年代末</strong>，图形通信协会(GCA)的Gen Code委员会<strong>研发出一种使用通用标签(Generic Tag)将不同类型的文档装配成由多个部分组成的复合型文档的方法</strong>。</p>
<p>　　此后，在该方面取得主要进展的是<strong>IBM公司</strong>的一个研发项目：<strong>广义标记语言(Generalized Markup Language，GML)</strong>。由Charles Goldfarb、Edward Mosher和Raymond Lorie三人主持的GML项目旨在提供一个能够在多重信息子系统中使用的文档编码解决方案。因为采用基于内容的标签，由GML编写的文档能够被编辑、格式化以及能够使用不同的程序进行检索。作为一个巨大的技术手册发布者，IBM已经广泛采用了GML，并以此证明了通用编码的生命力。</p>
<p>　　基于GML的成功，<strong>美国国家标准协会</strong>(American National Standards Institute，ANSI)在信息处理方向上建立了一个由Charles Goldfarb领导的项目小组，以研发一个基于GML的文本描述语言标准为目的。GCA的Gen Code委员会也为此项目贡献了力量。自20世纪70年代后期到80年代早期，该委员会发布了工作草案并最终提交了一个工业标准的候选方案(GCA 101-1983)，该候选方案被称为<strong>广义标记语言标准(the Standard Generalized MarkupLanguage，SGML)</strong>。该标准很快就被美国国防部(the U．S． Department of Defense)和美国国内税局(the U．S． Internal Revenue Service)采用。</p>
<p>　　在随后的几年里，SGML得到了世界上更多国家的认可。自1985年以来，世界上的SGML用户群体开始在英国集会。他们协同GCA一起将SGML在欧洲和北美进行推广，将SGML拓展到更广阔的领域。美国出版协会(the Association of American Publishers，AAP)的电子手稿项目(the Electronic Manuscript Project)将SGML标准应用于编制通用文档，如书籍和期刊等。美国国防部为其计算机辅助采集和后勤支持(Computer-Aided Acquisition and Logistic Support，CALS)小组开发基于SGML的应用程序，其中包括一种流行的表格格式文档类型称为CALS表格。<strong>鉴于SGML的成功，国际标准化组织(the International Standards Organization，ISO)采纳了SGML标准(ISO 8879：1986)。</strong></p>
<p>　　SGML被设计为一种灵活的，且无所不包的编码方案。和XML一样，SGML基本上是一个为开发专用化标记语言的工具箱。<strong>但是SGML比起XML来大得多，它具有更加灵活的语法以及更多的深奥参数。SGML过于灵活了，以至于开发一个能处理SGML的程序过于复杂和昂贵，只有那些能够承担得起软件开发以及SGML环境维护所需开销的大型机构才能获得SGML带来的好处</strong>。</p>
<p>　　在20世纪90年代早期，由<strong>欧洲粒子物理研究所的雇员Tim Berners-Lee和Anders Berglund发布了超文本标记语言</strong>，将通用编码革命性地引入到了公共大众的视野中。CERN早在1980开始致力于对SGML的研究和推广，当时就由Anders Berglund开发出一种出版系统用来测试SGML。<strong>随后Tim Berners-Lee和Anders Berglund提出一种支持超级文本的SGML文档，这种文档比SGML文档精简和有效。为该超级文本标记语言编写相应软件更为容易，且更容易对文档进行编码。据此，HTMI。得以由实验室应用迅速推广到全世界。HTML的出现极大地推动了世界范围内的互联网的发展，万维网就是一个主要成果。</strong></p>
<p>　　<strong>然而，HTML在某些方面是一种通用编码的倒退</strong>。第一，HTML为了获得精简编码方式的有效性，而抛弃了通用编码的一些基本原则。例如，通用编码要求一个文档类型能用于任何目的，要求用户编码时应重载标签而不是重新定义特殊目的的标签。第二，HTML中的很多标签是纯粹追求显示效果的，这显然与通用编码的初衷相违背。这种简化的结构很难区分文档的开始部分和结束部分。如今采用HTML编码的文档非常依赖纯格式化以致不能被用作其他目的。虽然HTML有着诸多的问题，但是我们不能抹杀它在标记语言的发展过程中为Web的发展带来飞跃所起到的重要作用。至少，HTML使得全世界的人对电子文档化和资源链接充满了兴趣。</p>
<p>　　<strong>为了回归到理想的通用编码状态，一些人试着改变SGML以适应Web，或者干脆改变Web以适应SGML，不幸的是，这被证实是非常困难的。</strong>SGML是如此的巨大，不可能被塞进小小的Web浏览器中。<strong>所以采用一种更小的，却又能保持SGML通用性的语言是唯一可行的途径，由此，令人兴奋不已的可扩展标记语言诞生了(xml)。</strong></p>
<p><strong>2.什么是SGML</strong>(Standard Generalized Markup Language，即<strong>标准通用标记语言</strong>)</p>
<p>该部分内容非重要内容，了解即可</p>
<p><a href="https://wiki.mbalib.com/wiki/SGML" target="_blank" rel="external">SGML</a>是国际上定义电子文档和内容描述的标准。它源于1969年IBM公司开发的文档描述语言GML，GML主要用来解决不同系统中文档格式不同的问题。后经过多年发展，1986年经ISO批准为国际标准ISO8897，并被称为SGML。</p>
<p>制定SGML的基本思想是把文档的内容与样式分开。在SGML中，标记分两种：一种用来描述文档显示的样式，称为<strong>程序标记</strong>；另一种用来描述文档中语句的用途，称为<strong>描述标记</strong>。<strong>一个SGML文件通常分三个层次：结构、内容和样式。</strong>结构为组织文档的元素提供框架，内容是信息本身，样式控制内容的显示。</p>
<p>SGML的平台无关性、结构化、可扩展等特性，使得它使用范围很广，被许多大型公司用来创建和发布信息。</p>
<p><strong>SGML的构成</strong></p>
<p>SGML文件本身包含3个部分：</p>
<ul>
<li><p>SGML声明(SGML Declaration)。</p>
</li>
<li><p>文档类型定义(Document Type Definition，<strong>DTD</strong>)。</p>
</li>
<li><p>文档实例(Document Instance)。</p>
</li>
</ul>
<p>其中，SGML声明是用来告诉SGML分析器(SGML Parser)在分析该份文件时，所使用的字符集和文件特性。</p>
<p>文件类型定义是用来声明该份文件的结构与语法参数，不同的“文件内容”使用不同的“标记”来描述。在这里所谓“标记”(Tag)是指用一特定符号将信息内容中的某一部分加以注记，而此特定符号就称为“标记”。如“＜”及“＞”都是一种标记。当然标记也可以是任何一小段文字。如“＜NAME＞”与“＜／NAME＞”，而“＜NAME＞Iamstudent＜／NAME＞”则是一段加上标记的字串。</p>
<p>　在SGML标记语言的术语中，“＜keyword”称为起始标记，相对的，“／keyvord＞”则称为结束标记。起始标记与结束标记是否一定要成对，可自行定义，而在起始标记与结束标记两者之间的文字“keyword”称为“元素”。至于文档实例，就是加上标记处理后的文件。</p>
<p><strong>SGML的优缺点</strong></p>
<ol>
<li><p>SGML的优点</p>
<ul>
<li><p>高稳定性<br>　　SGML的ISO 8879是国际标准规范，所以可信度相当高，其规范结构也相当的严谨，此外SGML已使用二十几年了，且自1996以来SGML的规范几乎是未曾变更过，所以SGML是相当成熟的一种通用性标记语言。</p>
</li>
<li><p>高可携性<br>　　SGML文件可以跨平台使用，如可以在不同的计算机硬件或操作系统上被使用，甚至可以被不同的应用软件来使用，因为SGML是一种高稳定性的国际标准，加上已使用二十几年，所以支持其格式的应用软件与相关数据转换技术就多，所以SGML文件可以在各应用领域中被广泛采用，当然其可携性相对就可以提高。</p>
</li>
<li><p>高完整性<br>　　制定SGML时就考虑须满足广泛的使用者，所以其规范制定得相当完整，可以满足不同应用领域使用者的需求，且与SGML搭配使用的家族如HyTime与DSSSL也都是国际标准，如HyTime符合ISO／IEC 10744的标准，主要功能是描述动态文件的一种语言，而DSSSL(Doeument Style Semantic And Specification Language)符合ISO/IEC 10179的标准，其制定目标有两个，一为制定SGML文件显示时的样本形式，另一个是有转换语言的功能。</p>
</li>
</ul>
</li>
<li><p>SGML的缺点</p>
<p> 上面提到SGML有高稳定性与完整性的优点，这可使得SGML可以适用在各类应用领域，但这相对的也是SGML致命的缺点。</p>
<ul>
<li><p>高复杂性</p>
<p>　　由于SGML的高度完整性与稳定性，相对的其复杂性也高，这一点可以说是SGML的主要缺陷，如果使用SGML语法规范来制定DTD中的元素(Element)、属性(Attribute)与内容实体(Entity)，可能需要花上数年的时间才能完全了解其中的标准，可见整个SGML系统是过于完善而变成复杂。</p>
<p>　　不止SGML本身复杂，连同要开发SGML相关软件也变得复杂，就开发SGML剖析器而言，用来检查SGML文件中的控制标记与格式，使用C++来撰写都得发上几万行以上才行咧!</p>
</li>
<li><p>费用昂贵</p>
<p>　　从SGML的高复杂性，其相对衍生出来的就是高费用，先前也提过SGML通常被大企业应用在大量的数据上，在SGML被应用之前必需先制定其文件格式定义DTD，以供使用者能遵循这个DTD中定义的文件结构，但其应用的文件数据通常是复杂的，所以制定该DTD也需花长时间才能完成，所以开发能适用的DTD的费用足相当昂贵的。</p>
</li>
</ul>
</li>
</ol>
<p><strong>SGML的标准体系</strong></p>
<p>　SGML标准的体系可分为三个层次：第一层次是元语言标准——SGML标准；第二层次是基础标准，如：文档样式语义与规范语言标准(DSSSL)等，是该体系的基本标准；第三层次是具体的应用标准，如：<strong>Internet上已广泛应用的HTML等标准</strong>。也就是说，在XML标准出现之前，SGML标准已经形成了完善的体系，并有许多建立于其上的应用系统与应用标准。如图所示。</p>
<p><img src="https://wiki.mbalib.com/w/images/e/e4/SGML%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB.jpg" alt=""></p>
<p><strong>SGML的现实问题</strong></p>
<p>SGML在其开发之初，是以作为一种规范性的标准为出发点的，因而重视详尽性，而忽视实用性成了它的致命弱点，可以这样说，SGML从来没有在网络上广泛应用过。具体而言：</p>
<p>　　第一、SGML是一个严格而完整的系统，方便软件应用并不是它的首要任务，所以SGML非常复杂，其复杂程度对于网络上的日常应用简直不可思议；</p>
<p>　　第二、SGML十分庞大，既不容易学，又不容易使用，在计算机上实现十分困难；</p>
<p>　　第三、在SGML中有许多语法语义标准，它们既不方便而且消耗昂贵，这导致开发SGML软件非常昂贵。目前比较便宜的SGML软件之一是Adobe Frame Maker，其标准版本价格为850美元，而Adobe Frame Maker+SGML是以1995美元售出的；</p>
<p>　　第四，种种不足，导致了几个主要的浏览器厂商都明确拒绝支持SGML，这无疑造成了SGML在网上传播的最大障碍。</p>
<p>　　鉴于以上因素，SGML已明显不适用于网络社会的需要，“如何使SGML能成功地运用于网络?”，这一问题已自然而然地提上了议程。1996年8月，GCA(图形通信协会)召集SGML开发者们举行了一次会议，与会者明确表示SGML在某些方面已经落伍了，这些种种不足已经成为了它广泛传播的障碍，讨论的结果认为有必要考虑怎样修补SGML。</p>
<p><strong>2.什么是HTML</strong></p>
<p><strong>超文本标记语言(HTML)起源于标准通用标记语言(SGML)</strong>，由世界上最大的粒子物理研究实验室欧洲核子研究中心CERN(the European Organization for Nuclear Research)于1991年首先提出，是推动Web迅速发展的原动力。在互联网发展的早期，为了在各种网络环境之间、不同文件格式之间进行交流，在SGML基础上，CERN提出了超文本标记语言(Hyper Text Markup Language，HTML)的概念。<strong>HTML是一种用来制作超文本文档的简单标记语言，它定义了一组标记符号(tag)，对文件的内容进行标注，指出内容的输出格式，如字体大小、颜色、背景颜色、表格形式、各部分之间逻辑上的组织等，从而实现了文件格式的标准化。</strong>简单地说，HTMI。文件包含了文档数据和显示样式两部分，其中文档数据是显示在Web浏览器中的数据内容，显示样式则规定了这些内容在浏览器中以何种格式、样子呈现给用户。通过统一使用支持HTMI。的浏览软件，用户可以在任意异构的网络环境中阅读同一个文件，得到相同的显示结果，并可以对文件进行跳跃式阅读，展现了很强的表现力。</p>
<p><strong>HTML的主要版本和发布时间</strong></p>
<p>HTMI主要版本和发布时间如下：</p>
<ol>
<li><p>HTML2．0，Internet工程任务组中的HTML工作组开发完成了HTML2．0，于1996年发布。</p>
</li>
<li><p>HTML3．2，W3C于1997年1月14El将其列为推荐版本，在HTMI2．0标准中添加了诸如字体、表格、Java程序、浮动、上标、下标等特征。</p>
</li>
<li><p>HTML4．0，W3C于1997年12月18Et将其列为推荐版本，第二个稍作修正的HTML4．0版本于1998年12月24Et发布。HTML4．0中最重要的特征是引入了样式表CSS技术。</p>
</li>
<li><p>HTML4．01，W3C于1999年12月24日将其列为推荐版本，是HTMI4．0的升级版本，它对原版本做出了部分修正。</p>
</li>
</ol>
<p>补充说明：html 4.01基于SGML，需要声明DTD。html5不基于SGML，所以不需要引用DTD。html是SGML的一个应用，xml是简化了SGML并用来取代SGML的，xhtml就是html从SGML专用xml语法的结果。</p>
<p><strong>3.什么是XML</strong></p>
<p><strong><a href="https://wiki.mbalib.com/wiki/XML" target="_blank" rel="external">XML</a>(扩展标记语言)是SGML的子集</strong>，其目标是允许普通的SGML在Web上以目前HTML的方式被服务、接收和处理。XML被设计成易于实现，且可在SGML和HTML之间互相操作。后来逐渐用于网络数据的转换和描述。</p>
<p>XML是一种专门在World Wide Web(www)上传递信息的语言，就像HTML(超文本标记语言)一样(自从Web出现以来，HTML已经成为了创建Web页的标准语言)。</p>
<p><strong>4.什么是XHTML</strong></p>
<p><a href="https://en.wikipedia.org/wiki/XHTML" target="_blank" rel="external">XHTML(可扩展超文本标记语言)</a> 是XML标记语言系列的一部分。它反映或扩展了广泛使用的超文本标记语言（HTML）的版本。是一种基于XML的HTML。它提供与HTML相同的功能，但具有与XML文档相同的规则。这些规则处理标记的结构，也是为了将HTML重新格式化为格式良好的XML。</p>
<p><strong>XHTML版本</strong></p>
<ul>
<li><p>XHTML 1.0 是一种SGML定义的HTML语言形式，它具有一些扩展的需求，以便逐渐兼容XML语法。</p>
</li>
<li><p>XHTML 1.1是一种用XML定义的，具备XML形式良好(well-formedness)要求的一种HTML语言。</p>
</li>
<li><p>XHTML 5代表“HTML 5的XML序列化”，是一种HTML5的XML语法，可以在将DOM树序列化回HTML5时使用，并且必须遵守更加严格的XML规则和名称空间。设计 XHTML 5的目的是为了让机器的阅读或数据交换更容易，或者便于比较两个HTML 5文档。 它是与HTML 5标准一起指定的。</p>
</li>
</ul>
<p><strong>与HTML的区别</strong></p>
<ul>
<li>从广义上讲，XML规则要求所有元素都可以通过单独的结束标记或使用自动关闭语法（例如<code>&lt;br/&gt;</code>）来关闭，而HTML语法允许某些元素未被封闭，因为它们总是空的（例如<code>&lt;input&gt;</code>）或它们的结束可以隐含地确定（例如遗漏<code>&lt;p&gt;</code>）。</li>
<li>XML对于元素和属性名称区分大小写，而HTML则不区分大小写。</li>
<li>HTML中省略了HTML中的一些速记特征，例如（1）属性最小化，其中可以省略属性值或它们的引用（例如，<code>&lt;option selected&gt;或者&lt;option selected=selected&gt;</code>，在XML中，这必须)。</li>
<li>关于命名空间和精确解析空格以及某些字符和元素，还有许多其他技术要求。</li>
<li>解析错误的行为不同。XML中的致命解析错误（例如错误的标记结构）导致文档处理中止。</li>
</ul>
<p><strong>5.总结</strong></p>
<ol>
<li>最早期的数据标记源于电子数据格式化，主要目的显示数据</li>
<li>为了脱离这种只可以对文档显示/拷贝打印的局限，可以更灵活的对文档进行操作，开始使用描述性标签取代格式码，<strong>通用编码</strong>开始出现。</li>
<li>随后有了广义标记语言(GML) -&gt; 广义标记语言标准(<strong>SGML</strong>) -&gt; <strong>国际标准化组织(ISO)采纳SGML标准</strong>(ISO 8879：1986)</li>
<li>20世纪90年代，为了在各种网络环境之间、不同文件格式之间进行交流，在SGML基础上，产生了html(超文本标记语言)。（在h5之前的html版本是SGML在应用上的一个具体实例，h5不是）。</li>
<li>然而，HTML在某些方面是一种通用编码的倒退，也具有局限性(编码格式)，为了克服这种局限性，试图回归到通用编码，w3c协会基于SGML创建了xml(可扩展性标记语言)，xml是SGML的子集，为SGML的简化而创建的。</li>
<li>开发XHTML是为了使HTML更具可扩展性，将HTML重新格式化为格式良好的xml，提高与其他数据格式的互操作性。作为一种合理的过渡。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从浏览器多进程到JS单线程，JS运行机制梳理(转载)]]></title>
      <url>http://www.skyshu.com/2018/10/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><strong>1.大纲</strong></p>
<blockquote>
<p>区分进程和线程</p>
<p>浏览器是多进程的</p>
<p>浏览器都包含哪些进程？</p>
<p>浏览器多进程的优势</p>
<p>重点是浏览器内核（渲染进程）</p>
<p>Browser进程和浏览器内核（Renderer进程）的通信过程</p>
<p>梳理浏览器内核中线程之间的关系</p>
<p>GUI渲染线程与JS引擎线程互斥</p>
<p>JS阻塞页面加载</p>
<p>WebWorker，JS的多线程？</p>
<p>WebWorker与SharedWorker</p>
<p>简单梳理下浏览器渲染流程</p>
<p>load事件与DOMContentLoaded事件的先后</p>
<p>css加载是否会阻塞dom树渲染？</p>
<p>普通图层和复合图层</p>
<p>从Event Loop谈JS的运行机制</p>
<p>事件循环机制进一步补充</p>
<p>单独说说定时器</p>
<p>setTimeout而不是setInterval</p>
<p>事件循环进阶：macrotask与microtask</p>
<p>写在最后的话</p>
</blockquote>
<p><strong>2.区分进程和线程</strong></p>
<p>线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：</p>
<ul>
<li><p>进程是一个工厂，工厂有它的独立资源</p>
</li>
<li><p>工厂之间相互独立</p>
</li>
<li><p>线程是工厂中的工人，多个工人协作完成任务</p>
</li>
<li><p>工厂内有一个或多个工人</p>
</li>
<li><p>工人之间共享空间</p>
</li>
</ul>
<p>再完善完善概念：</p>
<ul>
<li><p>工厂的资源 -&gt; 系统分配的内存（独立的一块内存）</p>
</li>
<li><p>工厂之间的相互独立 -&gt; 进程之间相互独立</p>
</li>
<li><p>多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务</p>
</li>
<li><p>工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成</p>
</li>
<li><p>工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</p>
</li>
</ul>
<p>然后再巩固下：</p>
<p>如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。</p>
<center><br><img width="80%" src="https://image-static.segmentfault.com/108/522/1085221355-5a6597253f28a_articlex"><br></center>

<p>所以，应该更容易理解了：<strong>进程是cpu资源分配的最小单位</strong>（系统会给它分配内存）</p>
<p>最后，再用较为官方的术语描述一遍：</p>
<ul>
<li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程) <strong>tips</strong></li>
</ul>
<p>不同进程之间也可以通信，不过代价较大<br>现在，一般通用的叫法：<strong>单线程与多线程</strong>，都是指在<strong>一个进程内</strong>的单和多。（所以核心还是得属于一个进程才行）</p>
<p><strong>3.浏览器是多进程的</strong></p>
<p>理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</p>
<ul>
<li>浏览器是多进程的</li>
<li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>
<li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。<br>关于以上几点的验证，请再第一张图：</li>
</ul>
<center><br><img width="80%" src="https://image-static.segmentfault.com/720/857/720857855-5a65972548fa1_articlex"><br></center>

<p>图中打开了Chrome浏览器的多个标签页，然后可以在Chrome的任务管理器中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。<br>感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上</p>
<p>注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了<br>（所以每一个Tab标签对应一个进程并不一定是绝对的）</p>
<p><strong>4.浏览器都包含哪些进程？</strong></p>
<p>知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）</p>
<ol>
<li><strong>Browser进程</strong>：<strong>浏览器的主进程</strong>（负责协调、主控），<strong>只有一个</strong>。作用有：<ul>
<li>负责浏览器界面显示，与用户交互。如前进，后退等</li>
<li>负责各个页面的管理，创建和销毁其他进程</li>
<li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li>
<li>网络资源的管理，下载等</li>
</ul>
</li>
</ol>
<ol>
<li>第三方插件进程：<strong>每种类型的插件对应一个进程</strong>，仅当使用该插件时才创建(如vue devtools)。</li>
</ol>
<ol>
<li>GPU进程：最多一个，用于3D绘制等。</li>
</ol>
<ol>
<li><strong>浏览器渲染进程（浏览器内核）</strong>（Renderer进程，内部是多线程的）：<strong>默认每个Tab页面一个进程</strong>，互不影响。主要作用为页面渲染，脚本执行，事件处理等。</li>
</ol>
<p>强化记忆：<strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</strong></p>
<p>当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图</p>
<p><img src="https://image-static.segmentfault.com/375/898/3758981650-5a659724661e6_articlex" alt=""></p>
<p>另外，可以通过Chrome的更多工具 -&gt; 任务管理器自行验证</p>
<p><strong>5.浏览器多进程的优势</strong></p>
<p>相比于单进程浏览器，多进程有如下优点：</p>
<ul>
<li>避免单个page crash影响整个浏览器</li>
<li>避免第三方插件crash影响整个浏览器</li>
<li>多进程充分利用多核优势</li>
<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>
</ul>
<p>简单点理解：<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。</strong></p>
<p>当然，内存等资源消耗也会更大，有点空间换时间的意思。</p>
<p><strong>6.重点是浏览器内核（渲染进程）</strong></p>
<p>重点来了，我们可以看到，上面提到了这么多的进程，那么，<strong>对于普通的前端操作来说，最重要的是什么呢</strong>？答案是<strong>渲染进程</strong></p>
<p>可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程</p>
<p><strong>请牢记，浏览器的渲染进程是多线程的</strong>（这点如果不理解，请回头看进程和线程的区分）</p>
<p>终于到了线程这个概念了?，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</p>
<ol>
<li>GUI(图形用户界面)渲染线程<ul>
<li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li>
<li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>
<li>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li>
</ul>
</li>
</ol>
<ol>
<li>JS引擎线程<ul>
<li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li>
<li>JS引擎线程负责解析Javascript脚本，运行代码。</li>
<li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li>
<li>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
</li>
</ol>
<ol>
<li>事件触发线程<ul>
<li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li>
<li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li>
<li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li>
</ul>
</li>
</ol>
<ol>
<li>定时触发器线程<ul>
<li>传说中的setInterval与setTimeout所在线程</li>
<li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li>
<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li>
<li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li>
</ul>
</li>
</ol>
<ol>
<li>异步http请求线程<ul>
<li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li>
</ul>
</li>
</ol>
<p>看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于事件触发线程的，所以如果仅仅是看某个碎片化知识，<br>可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：</p>
<center><br><img src="https://image-static.segmentfault.com/208/433/2084336019-5a65972413011_articlex"><br></center>

<p>再说一点，为什么JS引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计选择了单线程。。。</p>
<p><strong>6. Browser进程和浏览器内核（Renderer进程）的通信过程</strong></p>
<p> 看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，<br>这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。</p>
<p>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：<strong>任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程</strong>，<br>然后在这前提下，看下整个的过程：(简化了很多)</p>
<ul>
<li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程</li>
<li><p>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</p>
<ul>
<li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li>
<li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li>
<li>最后Render进程将结果传递给Browser进程</li>
</ul>
</li>
<li><p>Browser进程接收到结果并将结果绘制出来</p>
</li>
</ul>
<p>这里绘一张简单的图：（很简化）</p>
<center><br><img src="https://image-static.segmentfault.com/168/527/1685277292-5a65972377cb0_articlex"><br></center>

<p>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。</p>
<p>这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。</p>
<p>如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错</p>
<p><strong>7.梳理浏览器内核中线程之间的关系</strong></p>
<p>到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念</p>
<p><strong>8.GUI渲染线程与JS引擎线程互斥</strong></p>
<p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p>
<p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，<br>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p>
<p><strong>9.JS阻塞页面加载</strong></p>
<p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p>
<p>譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。<br>然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p>
<p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
<p><strong>10.WebWorker，JS的多线程？</strong></p>
<p>前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？</p>
<p>所以，后来HTML5中支持了<strong>Web Worker</strong>。</p>
<p>MDN的官方解释是：</p>
<pre><code>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面

一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 

这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window

因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误
</code></pre><p>这样理解下：</p>
<ul>
<li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li>
<li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li>
</ul>
<p>所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!</p>
<p>而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p>
<p>其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。</p>
<p><strong>11.WebWorker与SharedWorker</strong></p>
<p>既然都到了这里，就再提一下<strong>SharedWorker</strong>（避免后续将这两个概念搞混）</p>
<ul>
<li><p>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</p>
<ul>
<li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</li>
</ul>
</li>
<li><p>SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</p>
<ul>
<li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</li>
</ul>
</li>
</ul>
<p>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。<strong>SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</strong></p>
<p><strong>12.简单梳理下浏览器渲染流程</strong></p>
<p>本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本）</p>
<p>为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）</p>
<pre><code>- 浏览器输入url，浏览器主进程接管，开一个下载线程，
然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，
随后将内容通过RendererHost接口转交给Renderer进程

- 浏览器渲染流程开始
</code></pre><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p>
<pre><code>1.解析html建立dom树
2.解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
3.布局render树（Layout/reflow），负责各元素尺寸、位置的计算
4.绘制render树（paint），绘制页面像素信息
5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。
</code></pre><p>所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p>
<p>既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。</p>
<p>这里重绘参考来源中的一张图：（参考来源第一篇）</p>
<center><br><img src="https://image-static.segmentfault.com/137/309/1373095523-5a658fc12f1fd_articlex"><br></center>

<p><strong>13.load事件与DOMContentLoaded事件的先后</strong></p>
<p>上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？</p>
<p>很简单，知道它们的定义就可以了：</p>
<p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p>
<p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p>
<p>所以，顺序是：<code>DOMContentLoaded -&gt; load</code></p>
<p><strong>14.css加载是否会阻塞dom树渲染？</strong></p>
<p>这里说的是头部引入css的情况</p>
<p>首先，我们都知道：css是由单独的下载线程异步下载的。</p>
<p>然后再说下几个现象：</p>
<ul>
<li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</li>
<li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</li>
</ul>
<p>这可能也是浏览器的一种优化机制。</p>
<p>因为你加载css的时候，可能会修改下面DOM节点的样式，<br>如果css加载不阻塞render树渲染的话，那么当css加载完之后，<br>render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。<br>所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，<br>在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p>
<p><strong>15.普通图层和复合图层</strong></p>
<p>渲染步骤中就提到了<code>composite</code>概念。</p>
<p>可以简单的这样理解，浏览器渲染的图层一般包含两大类：<code>普通图层</code>以及<code>复合图层</code></p>
<p>首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）</p>
<p>其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。</p>
<p>然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源<br>（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p>
<p>可以简单理解下：<strong>GPU中，各个复合图层是单独绘制的，所以互不影响</strong>，这也是为什么某些场景硬件加速效果一级棒</p>
<p>可以<code>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>中看到，黄色的就是复合图层信息</p>
<p>如下图。可以验证上述的说法</p>
<p><img src="https://image-static.segmentfault.com/121/298/121298639-5a65972398326_articlex" alt=""></p>
<p><strong>如何变成复合图层（硬件加速）</strong></p>
<p>将该元素变成一个复合图层，就是传说中的硬件加速技术</p>
<ul>
<li>最常用的方式：<code>translate3d</code>、<code>translateZ</code></li>
<li><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li>
<li><code>will-chang</code>属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</li>
<li><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</li>
<li>其它，譬如以前的flash插件</li>
</ul>
<p><strong>absolute和硬件加速的区别</strong></p>
<p>可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。<br>所以，就算absolute中信息改变时不会改变普通文档流中render树，<br>但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。<br>（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p>
<p>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层<br>（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p>
<p><strong>复合图层的作用？</strong></p>
<p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</p>
<p>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</p>
<p><strong>硬件加速时请使用index</strong></p>
<p>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染</p>
<p>具体的原理时这样的：<br><strong>webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，<br>那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），<br>会默认变为复合层渲染，如果处理不当会极大的影响性能</strong></p>
<p>简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意</p>
<p>另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：</p>
<p><a href="http://web.jobbole.com/83575/" target="_blank" rel="external">http://web.jobbole.com/83575/</a></p>
<p><strong>16.从Event Loop谈JS的运行机制</strong></p>
<p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。</p>
<p>注意，这里不谈<code>可执行上下文</code>，<code>VO</code>，<code>scop chain</code>等概念（这些完全可以整理成另一篇文章了），这里主要是结合<code>Event Loop</code>来谈JS代码是如何执行的。</p>
<p>读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
</ul>
<p>然后再理解一个概念：</p>
<ul>
<li>JS分为同步任务和异步任务</li>
<li>同步任务都在主线程上执行，形成一个执行栈</li>
<li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>
<li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li>
</ul>
<p>看图：</p>
<center><br><img width="80%" src="https://image-static.segmentfault.com/352/134/3521345917-5a659722efdc2_articlex"><br></center>

<p>看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，<br>所以自然有误差。</p>
<p><strong>17.事件循环机制进一步补充</strong></p>
<p>这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《<a href="https://vimeo.com/96425312" target="_blank" rel="external">Help, I’m stuck in an event-loop</a>》）</p>
<center><br><img width="80%" src="https://image-static.segmentfault.com/110/313/1103131299-5a659722e7a98_articlex"><br></center>

<p>上图大致描述就是：</p>
<ul>
<li>主线程运行时会产生执行栈，栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）</li>
<li>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</li>
<li>如此循环</li>
<li>注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件</li>
</ul>
<p><strong>18.单独说说定时器</strong></p>
<p>上述事件循环机制的核心是：<strong>JS引擎线程和事件触发线程</strong></p>
<p>但事件上，里面还有一些隐藏细节，譬如调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？</p>
<p>是JS引擎检测的么？当然不是了。它是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身）</p>
<p><strong>为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</strong></p>
<p>什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p>
<p>譬如:</p>
<pre><code>setTimeout(function(){
    console.log(&apos;hello!&apos;);
}, 1000);
</code></pre><p>这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</p>
<pre><code>setTimeout(function(){
    console.log(&apos;hello!&apos;);
}, 0);

console.log(&apos;begin&apos;);
</code></pre><p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行</p>
<p>注意：</p>
<ul>
<li>执行结果是：先begin后hello!</li>
<li>虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。(不过也有一说是不同浏览器有不同的最小时间设定)</li>
<li>就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列）</li>
</ul>
<p><strong>19.setTimeout而不是setInterval</strong></p>
<p>用setTimeout模拟定期计时和直接用setInterval是有区别的。</p>
<p>因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差<br>（误差多少与代码执行时间有关）</p>
<p>而setInterval则是每次都精确的隔一段时间推入一个事件<br>（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</p>
<p>而且setInterval有一些比较致命的问题就是：</p>
<p>累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，<br>就会导致定时器代码连续运行好几次，而之间没有间隔。<br>就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）</p>
<ul>
<li>譬如像iOS的webview,或者Safari等浏览器中都有一个特点，在滚动的时候是不执行JS的，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误（这一块后续有补充，setInterval自带的优化，不会重复添加回调）</li>
<li>而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时</li>
</ul>
<p>所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame</p>
<p><strong>补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。</strong></p>
<p><strong>20.事件循环进阶：macrotask与microtask</strong></p>
<p>这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下），<br>强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：</p>
<p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="external">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p>
<p>上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：</p>
<pre><code>console.log(&apos;script start&apos;);

setTimeout(function() {
    console.log(&apos;setTimeout&apos;);
}, 0);

Promise.resolve().then(function() {
    console.log(&apos;promise1&apos;);
}).then(function() {
    console.log(&apos;promise2&apos;);
});

console.log(&apos;script end&apos;);
</code></pre><p>嗯哼，它的正确执行顺序是这样子的：</p>
<pre><code>script start
script end
promise1
promise2
setTimeout
</code></pre><p>为什么呢？因为Promise里有了一个一个新的概念：<code>microtask</code>(微任务)</p>
<p>或者，进一步，JS中分为两种任务类型：<strong>macrotask(宏任务)</strong>和<strong>microtask(微任务)</strong>，在ECMAScript中，<strong>microtask称为jobs，macrotask可称为task</strong></p>
<p>它们的定义？区别？简单点可以按如下理解：</p>
<ul>
<li><p>macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p>
<ul>
<li>每一个task会从头到尾将这个任务执行完毕，不会执行其它</li>
<li><p>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染</p>
<pre><code>task-&gt;渲染-&gt;task-&gt;...
</code></pre></li>
</ul>
</li>
<li><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</p>
<ul>
<li>也就是说，在当前task任务后，下一个task之前，在渲染之前</li>
<li>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染</li>
<li>也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）</li>
</ul>
</li>
</ul>
<p>分别很么样的场景会形成macrotask和microtask呢？</p>
<ul>
<li>macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）</li>
<li>microtask：Promise，process.nextTick等</li>
</ul>
<p><strong>补充：在node环境下，process.nextTick的优先级高于Promise</strong>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。</p>
<p>参考：<a href="https://segmentfault.com/q/1010000011914016" target="_blank" rel="external">https://segmentfault.com/q/1010000011914016</a></p>
<p>再根据线程来理解下：</p>
<ul>
<li>macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护</li>
<li>microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</li>
</ul>
<p>所以，总结下运行机制：</p>
<ul>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ul>
<p>如图：</p>
<center><br><img src="https://image-static.segmentfault.com/144/425/144425798-5a659724ab503_articlex"><br></center>

<p>另外，请注意下Promise的<code>polyfill</code>与官方版本的区别：</p>
<ul>
<li>官方版本中，是标准的microtask形式</li>
<li>polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式</li>
<li>请特别注意这两点区别</li>
</ul>
<p>注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），<br>但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p>
<p><strong>20180126补充：使用MutationObserver实现microtask</strong></p>
<p>MutationObserver可以用来实现microtask<br>（它属于microtask，优先级小于Promise，<br>一般是Promise不支持时才会这样做）</p>
<p>它是HTML5中的新特性，作用是：监听一个DOM变动，<br>当DOM对象树发生任何变动时，Mutation Observer会得到通知</p>
<p>像以前的Vue源码中就是利用它来模拟nextTick的，<br>具体原理是，创建一个TextNode并监听内容变化，<br>然后要nextTick的时候去改一下这个节点的文本内容，<br>如下：（Vue的源码，未修改）</p>
<pre><code>var counter = 1
var observer = new MutationObserver(nextTickHandler)
var textNode = document.createTextNode(String(counter))

observer.observe(textNode, {
    characterData: true
})
timerFunc = () =&gt; {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
}
</code></pre><p><a href="https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95" target="_blank" rel="external">对应Vue源码链接</a></p>
<p>不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因），<br>取而代之的是使用MessageChannel<br>（当然，默认情况仍然是Promise，不支持才兼容的）。</p>
<p>MessageChannel属于宏任务，优先级是：MessageChannel-&gt;setTimeout，<br>所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。</p>
<p>这里不展开，可以看下<a href="https://juejin.im/post/5a1af88f5188254a701ec230" target="_blank" rel="external">https://juejin.im/post/5a1af88f5188254a701ec230</a></p>
<p><strong>21.写在最后的话</strong><br>    该blog是我转载一个同年龄阶层人所写，看后收货很多，感慨也很深，差距确实很大。这里对自己学习认知上做个简要总结：</p>
<ul>
<li>获取知识的途径很重要，要多结识比自己优秀的人。</li>
<li>学习方式很重要，要学会系统化的学习(T)。</li>
<li>学习态度也很重要，要沉下心搞技术，不然一直会游离在技术的边缘。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cordova之创建APP]]></title>
      <url>http://www.skyshu.com/2018/10/24/cordova%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p><strong>1.概述</strong></p>
<p>Apache Cordova是一个开源的移动开发框架。允许用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等。</p>
<p>使用Apache Cordova的人群:</p>
<ul>
<li><p>移动应用开发者，想扩展一个应用的使用平台，而不通过每个平台的语言和工具集重新实现。</p>
</li>
<li><p>web开发者，想包装部署自己的web App将其分发到各个应用商店门户。</p>
</li>
<li><p>移动应用开发者，有兴趣混合原生应用组建和一个WebView(一个特别的浏览器窗口) 可以接触设备A级PI，或者你想开发一个原生和WebView组件之间的插件接口。</p>
</li>
</ul>
<p><strong>2.安装</strong></p>
<p>安装cordova命令行工具，通过下面这些步骤:</p>
<ol>
<li><p>下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm 。</p>
</li>
<li><p>(可选)下载和安装git client, 如果你没有。安装成功后，你可以在命令行中使用git。 这个命令行使用下载git仓库中的资源。</p>
</li>
<li><p>安装cordova 模块使用Nodejs的npm工具。cordova模块会被npm工具自动下载。</p>
</li>
</ol>
<ul>
<li><p>在OS X和Linux上:</p>
<pre><code>$ sudo npm install -g cordova
</code></pre><p>  在OS X和Linux上, npm命令加上前缀sudo因为cordova可能需要安装在其他的受限制目录比如 /usr/local/share。如果你使用可选工具nvm/nave或者具有安装目录的写权限，那么你可以省略sudo前缀。这里有更多提示 可用在使用 npm 没有 sudo前缀时，如果你想那么做。</p>
</li>
</ul>
<ul>
<li><p>在Windows上:</p>
<pre><code>C:\&gt;npm install -g cordova
</code></pre><p>  -g标志是告诉 npm 我们全局安装 cordova。否则我们将会安装在当前工作目录的 node_modules子目录。安装完成后，你应该能够在命令行中运行cordova命令，在没有任何参数的时候会打印一些帮助信息。</p>
</li>
</ul>
<p><strong>3.创建App</strong></p>
<p>跳转到你维护源代码的目录中，并创建你的cordova项目：</p>
<pre><code>$ cordova create hello com.example.hello HelloWorld
</code></pre><p>这将会为你的cordova应用创造必须的目录。默认情况下，cordova create命令生成基于web的应用程序的骨骼，项目的主页是 www/index.html 文件。<br>cordova create 到底做了些什么？根据官方描述该命令支持四个参数：</p>
<ol>
<li><strong>path</strong>：也就是项目的目录名称</li>
<li><strong>ID</strong>：项目的ID，用于写入config.xml的widget中，通常格式为 com.example.hello</li>
<li><strong>name</strong>：应用程序的显示名称</li>
<li><strong>options</strong>：项目的可选配置项<ul>
<li>–template：可执行项目的模版文件</li>
<li>–copy-from 指定src</li>
<li>–link-to 可将一个前端资源目录链接到项目的www目录下而不是一个副本</li>
</ul>
</li>
</ol>
<p><strong>通过部分 Cordova cli 源码我们可以大致知道Cordova是如何帮我们创建一个初始化工程的</strong></p>
<pre><code>var paths = {};
//从 cordova-app-hello-world npm包中获取config.xml文件
paths.configXml = path.join(require(&apos;cordova-app-hello-world&apos;).dirname, &apos;config.xml&apos;);
//从 cordova-app-hello-world npm包中获取 www 目录
paths.www = path.join(require(&apos;cordova-app-hello-world&apos;).dirname, &apos;www&apos;);
//从 cordova-app-hello-world npm包中获取 hooks 目录
paths.hooks = path.join(require(&apos;cordova-app-hello-world&apos;).dirname, &apos;hooks&apos;);
// 从 cordova-app-hello-world npm包中获取 package.json 文件
var dirAlreadyExisted = fs.existsSync(dir);//dir为 cordova create 的第一个参数 ptah
//判断当前path是否存在不存在直接创建
if (!dirAlreadyExisted) {
    fs.mkdirSync(dir);
}
try {
    //如果指定了 --template 则从模版复制项目到新项目下 
    if (cfg.lib.www.template) { copyTemplateFiles(import_from_path, dir, isSubDir); }
    //如果指定了 --link 则创建链接到项目
    if (cfg.lib.www.link) { linkFromTemplate(import_from_path, dir); }
    //如果没有没有指定 --template 或者 --link 则直接用 cordova-app-hello-world npm包
    copyIfNotExists(paths.www, path.join(dir, &apos;www&apos;));
    copyIfNotExists(paths.hooks, path.join(dir, &apos;hooks&apos;));
    var configXmlExists = projectConfig(dir); // moves config to root if in www
    if (paths.configXml &amp;&amp; !configXmlExists) {
        shell.cp(paths.configXml, path.join(dir, &apos;config.xml&apos;));
    }
} catch (e) {
    if (!dirAlreadyExisted) {
        shell.rm(&apos;-rf&apos;, dir);
    }
    if (process.platform.slice(0, 3) === &apos;win&apos; &amp;&amp; e.code === &apos;EPERM&apos;) {
        throw new CordovaError(&apos;Symlinks on Windows require Administrator privileges&apos;);
    }
    throw e;
}
//获取 package.json 文件
var pkgjsonPath = path.join(dir, &apos;package.json&apos;);
// Update package.json name and version fields
if (fs.existsSync(pkgjsonPath)) {
    delete require.cache[require.resolve(pkgjsonPath)];
    var pkgjson = require(pkgjsonPath);

    //指定项目名称，也就是我们 cordova create 命令的第三个参数
    if (cfg.name) {
        pkgjson.displayName = cfg.name;
    }
    //指定项目ID，也就是我们 cordova create 命令的第二个参数
    if (cfg.id) {
        pkgjson.name = cfg.id.toLowerCase();
    } else if (!cfg.id) {
        //设置默认ID为 helloworld
        pkgjson.name = &apos;helloworld&apos;;
    }
    pkgjson.version = &apos;1.0.0&apos;;
    fs.writeFileSync(pkgjsonPath, JSON.stringify(pkgjson, null, 4), &apos;utf8&apos;);
}
//创建 platforms(后期添加的Android和iOS平台都放在此文件夹) 和 plugins(插件)文件夹 
if (!fs.existsSync(path.join(dir, &apos;platforms&apos;))) { shell.mkdir(path.join(dir, &apos;platforms&apos;)); }
if (!fs.existsSync(path.join(dir, &apos;plugins&apos;))) { shell.mkdir(path.join(dir, &apos;plugins&apos;)); }
var configPath = path.join(dir, &apos;config.xml&apos;);
// only update config.xml if not a symlink
if (!fs.lstatSync(configPath).isSymbolicLink()) {
    // Write out id and name to config.xml; set version to 1.0.0 (to match package.json default version)
    var conf = new ConfigParser(configPath);
    if (cfg.id) conf.setPackageName(cfg.id);
    if (cfg.name) conf.setName(cfg.name);
    conf.setVersion(&apos;1.0.0&apos;);
    conf.write();
}
</code></pre><p>项目创建成功之后我们将得到如下目录结构</p>
<pre><code>hello/
|-- config.xml      #项目配置文件
|-- hooks/          #存放Cordova 的钩子
|-- node_modules/
|-- res/            #存放一些各平台的icon或者首屏图等资源
|-- www/            #静态网页资源
|-- platforms/      #各平台存放目录
|-- plugins/        #插件目录
|-- package.json
</code></pre><p><strong>4.添加平台</strong></p>
<p>所有后续命令都需要在项目目录或者项目目录的任何子目录运行:</p>
<pre><code>$ cd hello
</code></pre><p>为App添加目标平台。此处添加’android’平台，并确保其保存在了config.xml中:</p>
<pre><code>$ cordova platform add android --save
</code></pre><p>检查你当前平台设置状况:</p>
<pre><code>$ cordova platform ls
</code></pre><p>若成功添加Android平台，当前项目显示如下</p>
<pre><code>Installed platforms:
  android 7.0.0
Available platforms: 
  browser ~5.0.1
  ios ~4.5.4
  osx ~4.0.1
  windows ~5.0.0
  www ^3.12.0
</code></pre><p><strong>注意添加平台先决条件，需要为当前平台配置环境，安装平台所需的SDK。</strong> 除添加browser平台，它不需要任何平台SDK。<br>检测你是否满足构建平台的要求:</p>
<pre><code>$ cordova requirements
</code></pre><p>以Android为例，若平台环境安装好，显示如下：</p>
<pre><code>Requirements check results for android:
Java JDK: installed .
Android SDK: installed
Android target: installed android-19,android-21,android-22,android-23,Google Inc.:Google APIs:19,Google Inc.:Google APIs (x86 System Image):19,Google Inc.:Google APIs:23
Gradle: installed
</code></pre><p>以iOS为例，如平台环境未安装好，显示如下：</p>
<pre><code>Requirements check results for ios:
Apple OS X: not installed
Cordova tooling for iOS requires Apple OS X
Error: Some of requirements check failed
</code></pre><hr>
<p><strong>详细参见如下：</strong></p>
<ul>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/android/index.html#requirements-and-support" target="_blank" rel="external">Android平台的要求</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/ios/index.html#requirements-and-support" target="_blank" rel="external">iOS平台的要求</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/win8/index.html#requirements-and-support" target="_blank" rel="external">Windows平台的要求</a></li>
</ul>
<p><strong>5.构建App</strong></p>
<p>默认情况下, cordova create生产基于web应用程序的骨架，项目开始页面位于www/index.html 文件。任何初始化任务应该在www/js/index.js文件中的deviceready事件的事件处理函数中。</p>
<p>运行下面命令为所有添加的平台构建:</p>
<pre><code>$ cordova build
</code></pre><p>你可以在每次构建中选择限制平台范围 - 这个例子中是’android’:</p>
<pre><code>$ cordova build android
</code></pre><p><strong>6.测试App</strong></p>
<p>移动平台的SDK通常会绑定模拟器，它是一个可执行的设备镜像，这样你就可以在主屏幕启动你的App，看看它在多个平台是如何交互的。 在命令行运行下面的命令，会重新构建App并可以在特定平台的模拟器上查看:</p>
<pre><code>$ cordova emulate android
</code></pre><p>或者，你可以将你的手机插入电脑，在手机上直接测试App:</p>
<pre><code>$ cordova run android
</code></pre><p>在运行命令之前，你需要设置用于测试的设备，以下是每个平台的流程。</p>
<hr>
<p><strong>详细参见如下：</strong></p>
<ul>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/android/index.html#setting-up-an-emulator" target="_blank" rel="external">设置Android模拟器</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-cli/index.html#cordova-run-command" target="_blank" rel="external">Cordova run 命令参考文档</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-cli/index.html#cordova-emulate-command" target="_blank" rel="external">Cordova emulate 命令参考文档</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[原型链(—)]]></title>
      <url>http://www.skyshu.com/2018/10/23/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<p><strong>1.由来</strong>：</p>
<p>想象一个这种情况，2个对象，大部分内容都一样，只有一小部分不一样，很明显，在一个好的设计模式中，我们会需要重用那部分相同的，而不是在每个对象中重复定义那些相同的方法或者属性。在基于类[class-based]的系统中，这些重用部分被称为类的继承 – 相同的部分放入class A，然后class B和class C从A继承，并且可以声明拥有各自的独特的东西。</p>
<p>ECMAScript没有类的概念。但是，重用[reuse]这个理念没什么不同（某些方面，甚至比class-更加灵活），可以由prototype chain原型链来实现。这种继承被称为delegation based inheritance-基于继承的委托，或者更通俗一些，叫做原型继承。</p>
<p>类似于类”A”，”B”，”C”，在ECMAScript中尼创建对象类”a”，”b”，”c”，相应地， 对象“a” 拥有对象“b”和”c”的共同部分。同时对象“b”和”c”只包含它们自己的附加属性或方法。</p>
<pre><code>var a = {
     x: 10,
     calculate: function (z) {
   return this.x + this.y + z
     }
};

var b = {
  y: 20,
  __proto__: a
};

var c = {
  y: 30,
  __proto__: a
};

// 调用继承过来的方法
b.calculate(30); // 60
c.calculate(40); // 80
</code></pre><p>如果在对象b中找不到calculate方法(也就是对象b中没有这个calculate属性), 那么就会沿着原型链开始找。如果这个calculate方法在b的prototype中没有找到，那么就会沿着原型链找到a的prototype，一直遍历完整个原型链。记住，一旦找到，就返回第一个找到的属性或者方法。因此，第一个找到的属性成为继承属性。如果遍历完整个原型链，仍然没有找到，那么就会返回undefined。</p>
<p><strong>2.prototype、<strong>proto</strong>、Object、Function关系</strong></p>
<p>prototype: 每一个函数对象都有一个显示的prototype属性,它代表了对象的原型。</p>
<p><strong>proto</strong>:每个对象都有一个名为proto的内部隐藏属性，指向于它所对应的原型对象。</p>
<p>具体如下：</p>
<pre><code>function Animal(){

}
var  anim = new Animal();

console.log(&apos;***********Animal anim proto*****************&apos;);
console.log(&apos;typeof Animal.prototype:&apos; +typeof Animal.prototype);  //object 
console.log(&apos;anim.__proto__===Animal.prototype:&apos;+(anim.__proto__===Animal.prototype));  //true
console.log(&apos;Animal.__proto__===Function.prototype:&apos;+(Animal.__proto__===Function.prototype));  //true
console.log(&apos;Animal.prototype.__proto__===Object.prototype:&apos;+(Animal.prototype.__proto__===Object.prototype));  //true

console.log(&apos;***********Function proto*****************&apos;);
console.log(&apos;typeof Function.prototype:&apos;+typeof Function.prototype);  //function
console.log(&apos;typeof Function.__proto__:&apos;+typeof Function.__proto__);  //function
console.log(&apos;typeof Function.prototype.prototype:&apos;+typeof Function.prototype.prototype); //undefined
console.log(&apos;typeof Function.prototype.__proto__:&apos;+typeof Function.prototype.__proto__);   //object
console.log(&apos;Function.prototype===Function.__proto__:&apos;+(Function.prototype===Function.__proto__)); //true

console.log(&apos;***********Object proto*****************&apos;);
console.log(&apos;typeof Object.prototype:&apos;+typeof Object.prototype);  //object
console.log(&apos;typeof Object.__proto__:&apos;+typeof Object.__proto__);  //function
console.log(&apos;Object.prototype.prototype:&apos;+Object.prototype.prototype);  //undefied
console.log(&apos;Object.prototype.__proto__===null:&apos;+(Object.prototype.__proto__===null));  //null

console.log(&apos;***********Function Object  proto关系*****************&apos;);
console.log(&apos;Function.prototype===Object.__proto__:&apos;+(Function.prototype===Object.__proto__));   //true
console.log(&apos;Function.__proto__===Object.__proto__:&apos;+(Function.__proto__===Object.__proto__));   //true
console.log(&apos;Function.prototype.__proto__===Object.prototype:&apos;+(Function.prototype.__proto__===Object.prototype));   //true

/********************* 系统定义的对象Array、Date ****************************/
console.log(&apos;**************test Array、Date****************&apos;);      
var array = new Array();
var date = new Date();
console.log(&apos;array.__proto__===Array.prototype:&apos;+(array.__proto__===Array.prototype));   //true
console.log(&apos;Array.__proto__===Function.prototype:&apos;+(Array.__proto__===Function.prototype));  //true
console.log(&apos;date.__proto__===Date.prototype:&apos;+(date.__proto__===Date.prototype));    //true
console.log(&apos;Date.__proto__===Function.prototype:&apos;+(Date.__proto__===Function.prototype));     //true
</code></pre><p>所有对象，包括函数对象的原型链最终都指向了Object.prototype，而Object.prototype.proto===null，原型链至此结束。<br>Animal.prototype是一个普通对象。<br>Object是一个函数对象，也是Function构造的，Object.prototype是一个普通对象。<br>Object.prototype.type指向null。<br>Function.prototype是一个函数对象，前面说函数对象都有一个显示的prototype属性，但是Function.prototype却没有prototype属性，即Function.prototype.prototype===undefined，所有Function.prototype函数对象是一个特例，没有prototype属性。<br>Object虽是Function构造的一个函数对象，但是Object.prototype没有指向Function.prototype，即Object.prototype!==Function.prototype。</p>
<p><strong>3.Prototype跟Constructor关系</strong></p>
<p>在 JavaScript 中，每个函数对象都有名为“prototype”的属性(上面提到过Function.prototype函数对象是个例外，没有prototype属性)，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用（i.e. Animal.prototype.constructor===Animal）。</p>
<pre><code>console.log(&apos;anim.constructor===Animal:&apos;+(anim.constructor===Animal))    ;    //true
console.log(&apos;Animal===Animal.prototype.constructor:&apos;+(Animal===Animal.prototype.constructor))    ;    //true
console.log(&apos;Animal.constructor===Function.prototype.constructor:&apos;+(Animal.constructor===Function.prototype.constructor));   //true
console.log(&apos;Function.prototype.constructor===Function:&apos;+(Function.prototype.constructor===Function));    //true
console.log(&apos;Function.constructor===Function.prototype.constructor:&apos;+(Function.constructor===Function.prototype.constructor));    //true
console.log(&apos;Object.prototype.constructor===Object:&apos;+(Object.prototype.constructor===Object));    //true
console.log(&apos;Object.constructor====Function:&apos;+(Object.constructor===Function));    //true
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单例模式]]></title>
      <url>http://www.skyshu.com/2018/10/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><strong>1.概念</strong></p>
<p>单例是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。(在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。）</p>
<p><strong>2.实现与使用场景</strong></p>
<p>2.1 使用对象字面量的方法实现，其字面量里可以包含大量的属性和方法: </p>
<pre><code>var mySingleton = {
property1: &quot;something&quot;,
property2: &quot;something else&quot;,
method1: function () {
    console.log(&apos;hello world&apos;);
}
};
</code></pre><p>要扩展该对象，可以添加私有成员和方法，然后使用闭包在其内部封装这些变量和函数声明。只暴露public成员和方法，样例代码如下：</p>
<pre><code>var mySingleton = function () {

/* 这里声明私有变量和方法 */
var privateVariable = &apos;something private&apos;;
function showPrivate() {
    console.log(privateVariable);
}

/* 公有变量和方法（可以访问私有变量和方法） */
return {
    publicMethod: function () {
        showPrivate();
    },
    publicVar: &apos;the public can see this!&apos;
};
};

var single = mySingleton();
single.publicMethod();  // 输出 &apos;something private&apos;
console.log(single.publicVar); // 输出 &apos;the public can see this!&apos;
</code></pre><p>为了节约资源的目的，我们可以另外一个构造函数里来初始化这些代码，如下：</p>
<pre><code>var Singleton = (function () {
var instantiated;
function init() {
    /*这里定义单例代码*/
    return {
        publicMethod: function () {
            console.log(&apos;hello world&apos;);
        },
        publicProperty: &apos;test&apos;
    };
}

return {
    getInstance: function () {
        if (!instantiated) {
            instantiated = init();
        }
        return instantiated;
    }
};
})();

/*调用公有的方法来获取实例:*/
Singleton.getInstance().publicMethod();
</code></pre><p>2.2 场景</p>
<p>单例一般是用在系统间各种模式的通信协调上，下面的代码是一个单例的最佳实践：</p>
<pre><code>var SingletonTester = (function () {

//参数：传递给单例的一个参数集合
function Singleton(args) {

    //设置args变量为接收的参数或者为空（如果没有提供的话）
    var args = args || {};
    //设置name参数
    this.name = &apos;SingletonTester&apos;;
    //设置pointX的值
    this.pointX = args.pointX || 6; //从接收的参数里获取，或者设置为默认值
    //设置pointY的值
    this.pointY = args.pointY || 10;

}

//实例容器
var instance;

var _static = {
    name: &apos;SingletonTester&apos;,

    //获取实例的方法
    //返回Singleton的实例
    getInstance: function (args) {
        if (instance === undefined) {
            instance = new Singleton(args);
        }
        return instance;
    }
};
return _static;
})();

var singletonTest = SingletonTester.getInstance({ pointX: 5 });
console.log(singletonTest.pointX); // 输出 5 
</code></pre><p>其他实现方式：</p>
<ul>
<li><p>方法1</p>
<pre><code>function Universe() {

// 判断是否存在实例
if (typeof Universe.instance === &apos;object&apos;) {
    return Universe.instance;
}

// 其它内容
this.start_time = 0;
this.bang = &quot;Big&quot;;

// 缓存
Universe.instance = this;

// 隐式返回this
}

// 测试
var uni = new Universe();
var uni2 = new Universe();
console.log(uni === uni2); // true
</code></pre></li>
<li><p>方法2</p>
<pre><code>function Universe() {

// 缓存的实例
var instance = this;

// 其它内容
this.start_time = 0;
this.bang = &quot;Big&quot;;

// 重写构造函数
Universe = function () {
    return instance;
};

}

// 测试
var uni = new Universe();
var uni2 = new Universe();
uni.bang = &quot;123&quot;;
console.log(uni === uni2); // true
console.log(uni2.bang); // 123
</code></pre></li>
<li><p>方法3</p>
<pre><code>function Universe() {

// 缓存实例
var instance;

// 重新构造函数
Universe = function Universe() {
    return instance;
};

// 后期处理原型属性
Universe.prototype = this;

// 实例
instance = new Universe();

// 重设构造函数指针
instance.constructor = Universe;

// 其它功能
instance.start_time = 0;
instance.bang = &quot;Big&quot;;

return instance;

}

    // 测试
    var uni = new Universe();
    var uni2 = new Universe();
    console.log(uni === uni2); // true

    // 添加原型属性
    Universe.prototype.nothing = true;

    var uni = new Universe();

    Universe.prototype.everything = true;

    var uni2 = new Universe();

    console.log(uni.nothing); // true
    console.log(uni2.nothing); // true
    console.log(uni.everything); // true
    console.log(uni2.everything); // true
    console.log(uni.constructor === Universe); // true
</code></pre></li>
<li><p>方法4</p>
<pre><code>var Universe;

(function () {

    var instance;

    Universe = function Universe() {

        if (instance) {
            return instance;
        }

        instance = this;

        // 其它内容
        this.start_time = 0;
        this.bang = &quot;Big&quot;;
    };
} ());

//测试代码
var a = new Universe();
var b = new Universe();
console.log(a === b); // true
a.bang = &quot;123&quot;;
console.log(b.bang); // 123
</code></pre></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[变量的解构赋值]]></title>
      <url>http://www.skyshu.com/2018/10/22/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      <content type="html"><![CDATA[<p><strong>1.解构概念</strong></p>
<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值</strong>，这被称为解构（Destructuring）。</p>
<p><strong>2.数组的解构赋值</strong></p>
<p>2.1 基本用法</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code>let a = 1;
let b = 2;
let c = 3;
</code></pre><p>ES6 允许写成下面这样。</p>
<pre><code>let [a, b, c] = [1, 2, 3];
</code></pre><p><strong>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</strong> 下面是一些使用嵌套数组进行解构的例子。</p>
<pre><code>let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&apos;a&apos;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<pre><code>let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
</code></pre><p>2.2 默认值</p>
<p>解构赋值允许指定默认值。</p>
<pre><code>let [foo = true] = [];
foo // true

let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;
let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;
</code></pre><p><strong>3.对象解构</strong></p>
<p>解构不仅可以用于数组，还可以用于对象。</p>
<pre><code>let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
</code></pre><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code>let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined
</code></pre><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<p>这实际上说明，对象的解构赋值是下面形式的简写</p>
<pre><code>let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
</code></pre><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。<strong>真正被赋值的是后者，而不是前者。</strong></p>
<pre><code>let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p>
<p><strong>4.字符串的解构赋值</strong></p>
<pre><code>const [a, b, c, d, e] = &apos;hello&apos;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
</code></pre><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<pre><code>let {length : len} = &apos;hello&apos;;
len // 5
</code></pre><p><strong>5.数值和布尔值的解构赋值</strong></p>
<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<pre><code>let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
</code></pre><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<p><strong>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。</strong>由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<pre><code>let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
</code></pre><p><strong>6.函数参数的解构赋值</strong></p>
<p>函数的参数也可以使用解构赋值。</p>
<pre><code>function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
</code></pre><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<p>函数参数的解构也可以使用默认值。</p>
<pre><code>function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre><p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p>
<p><strong>7.用途</strong></p>
<ul>
<li><p>交换变量的值</p>
<pre><code>let x = 1;
let y = 2;
[x, y] = [y, x];
</code></pre><p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
</li>
<li><p>从函数返回多个值</p>
</li>
</ul>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<pre><code>// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
</code></pre><ul>
<li>函数参数的定义</li>
</ul>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code>// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
</code></pre><ul>
<li>提取 JSON 数据</li>
</ul>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<pre><code>let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre><p>上面代码可以快速提取 JSON 数据的值。</p>
<ul>
<li>函数参数的默认值</li>
</ul>
<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<pre><code>jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
</code></pre><ul>
<li>遍历 Map 结构</li>
</ul>
<p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code>const map = new Map();
map.set(&apos;first&apos;, &apos;hello&apos;);
map.set(&apos;second&apos;, &apos;world&apos;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
</code></pre><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code>// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
</code></pre><ul>
<li>输入模块的指定方法</li>
</ul>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<pre><code>const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ES6下Proxy(代理模式)]]></title>
      <url>http://www.skyshu.com/2018/10/22/Proxy/</url>
      <content type="html"><![CDATA[<p><strong>1.概述</strong></p>
<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre><code>var obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`);
    return Reflect.set(target, key, value, receiver);
  }
});
</code></pre><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。</p>
<pre><code>obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
</code></pre><p>上面代码说明，Proxy <strong>实际上重载（overload）了点运算符</strong>，即用自己的定义覆盖了语言的原始定义(重写setter,getter方法)。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code>var proxy = new Proxy(target, handler);
</code></pre><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，<strong>new Proxy()表示生成一个Proxy实例</strong>，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<pre><code>var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35
</code></pre><p>上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。</p>
<p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p><strong>如果handler没有设置任何拦截，那就等同于直接通向原对象。</strong></p>
<pre><code>var target = {};
var handler = {};
var proxy = new Proxy(target, handler);
proxy.a = &apos;b&apos;;
target.a // &quot;b&quot;
</code></pre><p>上面代码中，handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。</p>
<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<pre><code>var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
</code></pre><p>上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li><p>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</p>
</li>
<li><p>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</p>
</li>
<li><p>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</p>
</li>
<li><p>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</p>
</li>
<li><p>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</p>
</li>
<li><p>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p>
</li>
<li><p>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p>
</li>
<li><p>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</p>
</li>
<li><p>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</p>
</li>
<li><p>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</p>
</li>
<li><p>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
</li>
<li><p>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p>
</li>
<li><p>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p>
</li>
</ul>
<p><strong>2.Proxy 实例的方法</strong></p>
<ul>
<li>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为<strong>目标对象、属性名和 proxy 实例本身</strong>（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</li>
</ul>
<p>get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<p>var person = {<br>  name: “张三”<br>};</p>
<p>var proxy = new Proxy(person, {<br>  get: function(target, property) {<br>    if (property in target) {<br>      return target[property];<br>    } else {<br>      throw new ReferenceError(“Property \”” + property + “\” does not exist.”);<br>    }<br>  }<br>});</p>
<p>proxy.name // “张三”<br>proxy.age // 抛出一个错误</p>
<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。</p>
<ul>
<li>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为<strong>目标对象、属性名、属性值和 Proxy 实例本身</strong>，其中最后一个参数可选。</li>
</ul>
<p>假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。</p>
<pre><code>let validator = {
  set: function(obj, prop, value) {
    if (prop === &apos;age&apos;) {
      if (!Number.isInteger(value)) {
        throw new TypeError(&apos;The age is not an integer&apos;);
      }
      if (value &gt; 200) {
        throw new RangeError(&apos;The age seems invalid&apos;);
      }
    }

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  }
};

let person = new Proxy({}, validator);

person.age = 100;

person.age // 100
person.age = &apos;young&apos; // 报错
person.age = 300 // 报错
</code></pre><p>上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。</p>
<pre><code>const handler = {
  get (target, key) {
    invariant(key, &apos;get&apos;);
    return target[key];
  },
  set (target, key, value) {
    invariant(key, &apos;set&apos;);
    target[key] = value;
    return true;
  }
};
function invariant (key, action) {
  if (key[0] === &apos;_&apos;) {
    throw new Error(`Invalid attempt to ${action} private &quot;${key}&quot; property`);
  }
}
const target = {};
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private &quot;_prop&quot; property
proxy._prop = &apos;c&apos;
// Error: Invalid attempt to set private &quot;_prop&quot; property
</code></pre><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js的垃圾回收机制]]></title>
      <url>http://www.skyshu.com/2018/10/19/js%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><strong>1.垃圾回收机制由来</strong></p>
<p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。为此系统提供相应的垃圾回收机制。</p>
<p><strong>2.方式</strong></p>
<p>现在各大浏览器通常用采用的垃圾回收有两种方法：<strong>标记清除</strong>、<strong>引用计数</strong>。</p>
<ul>
<li><p><strong>标记清除</strong></p>
<p>  这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p>
<p>  垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<p>  大部分浏览器都是使用这种方式进行垃圾回收，区别在于如何标记及垃圾回收间隔而已，而低版本IE采用的则是<strong>引用计数方式</strong>进行垃圾回收。</p>
</li>
<li><p><strong>引用计数</strong></p>
<p>  引用计数是一种不太常见的垃圾回收方式。</p>
<p>  引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p>
<p>  但这种方式很容易由于循环引用造成内存泄漏。比如对象A有一个属性指向对象B，而对象B也有有一个属性指向对象A，这样相互引用</p>
<pre><code>function test(){
    var objA={};
    var objB={};
    a.prop=b;
    b.prop=a;
}
</code></pre></li>
</ul>
<pre><code>这个例子中，objA和objB通过各自的属性相互引用，也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。      
</code></pre><p>   而在标记清除的策略下是没有问题的，离开环境的就被清除。</p>
<pre><code>我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object 
</code></pre><p>Model，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使IE的Javascript引擎使用标记清除的策略来实现的，但JavaScript访问的COM对象依然是基于引用计数的策略的。说白了，只要IE中涉及COM对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p>
<pre><code>window.onload=function outerFunction(){
    var obj = document.getElementById(&quot;element&quot;);
    obj.onclick=function innerFunction(){};
};
</code></pre><p>上述例子obj引用了document.getElementById(“element”)，而document.getElementById(“element”)的onclick方法会引用外部环境中德变量，自然也包括obj。由于循环引用，也将会造成内存无法回收。</p>
<p>最简单的方式就是自己手工解除循环引用，如下</p>
<pre><code>window.onload=function outerFunction(){
    var obj = document.getElementById(&quot;element&quot;);
    obj.onclick=function innerFunction(){};
   obj=null;
};
</code></pre><p><strong>3.减少JavaScript中的垃圾回收</strong></p>
<p>首先，最明显的，new关键字就意味着一次内存分配，例如 new Foo()。最好的处理方法是：在初始化的时候新建对象，然后在后续过程中尽量多的重用这些创建好的对象。</p>
<p>另外还有以下三种内存分配表达式（可能不像new关键字那么明显了）：</p>
<ul>
<li><p>{} （创建一个新对象）</p>
</li>
<li><p>[] （创建一个新数组）</p>
</li>
<li><p>function() {…} (创建一个有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。新的方法，注意：新建方法也会导致垃圾收集！)</p>
</li>
</ul>
<p><strong>3.1 对象object优化</strong></p>
<p>为了最大限度的实现对象的重用，应该像避使用new语句一样避免使用{}来新建对象。</p>
<p>有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。</p>
<p>cr.wipe(obj)方法就是为此功能而生，代码如下：</p>
<pre><code>// 删除obj对象的所有属性，高效的将obj转化为一个崭新的对象！
cr.wipe = function (obj) {
    for (var p in obj) {
         if (obj.hasOwnProperty(p))
            delete obj[p];
    }
};        
</code></pre><p>有些时候，你可以使用cr.wipe(obj)方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取“新对象”的做法，比简单的通过{}来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！</p>
<p><strong>3.2 数组array优化</strong></p>
<p>将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p>
<p><strong>3.3 方法function优化</strong></p>
<p> 方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。</p>
<p>在游戏的主循环中，setTimeout或requestAnimationFrame来调用一个成员方法是很常见的，例如：</p>
<pre><code>setTimeout(
    (function(self) {                    
      return function () { self.tick();}
    })(this), 16)
</code></pre><p>每过16毫秒调用一次this.tick()，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！为了解决这个问题，可以将作为返回值的方法保存起来，例如:</p>
<pre><code>// at startup
this.tickFunc = (
    function(self) {
      return function() {
                self.tick();
      };
    }
)(this);

// in the tick() function
setTimeout(this.tickFunc, 16);
</code></pre><p>相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[定位简析]]></title>
      <url>http://www.skyshu.com/2018/09/29/%E7%BD%91%E7%BB%9C%E5%AE%9A%E4%BD%8D/</url>
      <content type="html"><![CDATA[<p><strong>定位方式</strong>:<br>定位分为<strong>GPS定位</strong>和<strong>网络定位</strong>2种。</p>
<p>GPS定位: 精度较高，可达到10米，但室内不可用，且超级费电。</p>
<p>网络定位: 分为wifi定位和基站定位，都是通过获取wifi或者基站信息，然后查询对应的wifi或者基站位置数据库，得到的定位地点。定位数据库可以不断完善不断补充，所以，越定位越准确。(常见的浏览器定位，IP定位也是网络定位)。</p>
<p><strong>HTML5地理定位</strong></p>
<p>目前前端采用的主流定位方式是基于H5所提供API进行定位。</p>
<p>H5 Geolocation API定位原理:<br>Geolocation API 是基于新增加的全局对象 navigator：<strong>navigator.geolocation</strong>。JavaScript 对象<br>navigator 包含了很有用的有关访问者的浏览器和系统的信息。<strong>Geolocation 可以使用 IP 地址、基于 Web 的数据库、无线网络连接和三角测量或 GPS 技术来确定经度和纬度。</strong></p>
<p>navigator.geolocation对象说明:</p>
<p><code>方法</code></p>
<ul>
<li><p>getCurrentPosition()</p>
<p>  navigator.geolocation.getCurrentPosition(geolocationSuccess,geolocationError,geolocationOptions);<br>  [geolocationSuccess]– 成功后的回调函数<br>  [geolocationError] – 失败后的回调函数<br>  [geolocationOptions] – 相关配置参数：</p>
<pre><code>enableHighAccuracy – 确保应用会给出最佳结果。
这有可能会让浏览器的反应时间变慢。如果是移动装置，还有可能因
为使用GPS而消耗更多电量。接受参数类型为boolean，默认为false。

timeout – 接受一个数字作为参数，默认为0微秒。设置浏览器的超时时间。 

maximumAge – 表示程序能接受的被缓存位置的最大过期时间。
接受一个数字作为参数，默认为0微秒。这就意味这默认每次获取位置都必需重新获取一个新位置。
</code></pre></li>
</ul>
<ul>
<li><p>watchPosition()<br> watchPosition()方法实现同getCurrentPosition()，区别在于getCurrentPosition() 方法能够获取用户的当前位置，但是只能获取一次。<br> watchPosition() 方法会定期查询用户的位置，观察用户位置是否发生了变化。所以基本上它一直在更新用户的位置。当你在移动的时候，这个功能会非常有利于追踪用户的位置。这个函数还会返回一个watchID值被clearWatch使用来停止监控。</p>
</li>
<li><p>clearWatch()</p>
<p> 这个方法接受一个参数，需要清理的观察进程的id：watchID（这个参数由watchPosition方法返回）。</p>
<pre><code>navigator.geolocation.clearWatch(watchID)
</code></pre></li>
</ul>
<p><code>属性</code></p>
<p>地理位置对象 Position</p>
<p>Geolocation API 的成功函数回调会返回一个地理位置对象 Position。这个对象具有两个属性：timestamp 和 coords。<strong>timestamp</strong> 属性表示地理数据创建的时间。而 <strong>coords</strong> 属性包含了 7 个属性：</p>
<ul>
<li>coords.latitude. 估算的纬度 </li>
<li>coords.longitude. 估算的经度</li>
<li>coords.altitude. 估算的高度 (以米为单位的海拔值) </li>
<li>coords.accuracy. 所得经度和纬度的估算精度，以米为单位 </li>
<li>coords.altitudeAccuracy. 所得高度的估算精度，以米为单位 </li>
<li>coords.heading. 宿主设备的当前移动方向，以度为单位，相对于正北方向顺时针方向计算</li>
<li>coords.speed. 设备的当前对地速度，以米/秒为单位</li>
</ul>
<p>这里只有 3 个属性是必需的：coords.latitude、coords.longitude 和 coords.accuracy。其他属性返回 null，取决于设备及其交互的后端定位服务器的功能。heading 和 speed 属性是基于用户的前一个位置计算的（如果有）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ES6中promise的使用]]></title>
      <url>http://www.skyshu.com/2018/09/29/promise/</url>
      <content type="html"><![CDATA[<p><strong>1.Promise 概念</strong></p>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p><strong>2.基本用法</strong></p>
<p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<pre><code>const promise = new Promise(function(resolve, reject) {
      // ... some code

      if (/* 异步操作成功 */){
        resolve(value);
      } else {
        reject(error);
      }
});
</code></pre><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<pre><code>promise.then(function(value) {
      // success
}, function(error) {
      // failure
});
</code></pre><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<p>举例用Promise对象实现的 Ajax 操作的例子。</p>
<pre><code>const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();
  });
  return promise;
};

getJSON(&quot;/posts.json&quot;).then(function(json) {
  console.log(&apos;Contents: &apos; + json);
}, function(error) {
  console.error(&apos;出错了&apos;, error);
});
</code></pre><p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p><strong>3.原型方法</strong></p>
<p><strong>3.1 Promise.prototype.then()</strong></p>
<p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<p><strong>then方法返回的是一个新的Promise实例</strong>（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<pre><code>getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre><p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log(&quot;resolved: &quot;, comments);
}, function funcB(err){
  console.log(&quot;rejected: &quot;, err);
});
</code></pre><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;resolved: &quot;, comments),
  err =&gt; console.log(&quot;rejected: &quot;, err)
);
</code></pre><p><strong>3.2 Promise.prototype.catch()</strong></p>
<p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<pre><code>getJSON(&apos;/posts.json&apos;).then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&apos;发生错误！&apos;, error);
});
</code></pre><p>上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<pre><code>p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));

// 等同于
p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre><p><strong>3.3 Promise.prototype.finally()</strong></p>
<p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的</p>
<pre><code>promise
.then(result =&gt; {···})
.catch(error =&gt; {···})
.finally(() =&gt; {···});
</code></pre><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。</p>
<pre><code>server.listen(port)
  .then(function () {
    // ...
  })
  .finally(server.stop);
</code></pre><p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p>finally本质上是then方法的特例。</p>
<pre><code>promise
.finally(() =&gt; {
  // 语句
});

// 等同于
promise
.then(
  result =&gt; {
    // 语句
    return result;
  },
  error =&gt; {
    // 语句
    throw error;
  }
);
</code></pre><p>上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。</p>
<p>它的实现也很简单。</p>
<pre><code>Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};
</code></pre><p>上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。</p>
<p>从上面的实现还可以看到，finally方法总是会返回原来的值。</p>
<pre><code>// resolve 的值是 undefined
Promise.resolve(2).then(() =&gt; {}, () =&gt; {})

// resolve 的值是 2
Promise.resolve(2).finally(() =&gt; {})

// reject 的值是 undefined
Promise.reject(3).then(() =&gt; {}, () =&gt; {})

// reject 的值是 3
Promise.reject(3).finally(() =&gt; {})
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[300毫秒延时]]></title>
      <url>http://www.skyshu.com/2018/09/21/300%E6%AF%AB%E7%A7%92/</url>
      <content type="html"><![CDATA[<p><strong>一、问题来源:</strong></p>
<p>这要追溯至 2007 年初。苹果公司在发布首款 iPhone 前夕，遇到一个问题：当时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览桌面端站点的问题。</p>
<p>这当中最出名的，当属双击缩放(double tap to zoom)，这也是会有上述 300 毫秒延迟的主要原因。</p>
<p>双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 那么这和 300 毫秒延迟有什么联系呢？ 假定这么一个场景。用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 鉴于iPhone的成功，其他移动浏览器都复制了 iPhone Safari 浏览器的多数约定，包括双击缩放，几乎现在所有的移动端浏览器都有这个功能。之前人们刚刚接触移动端的页面，在欣喜的时候往往不会care这个300ms的延时问题，可是如今touch端界面如雨后春笋，用户对体验的要求也更高，这300ms带来的卡顿慢慢变得让人难以接受。</p>
<p>简而言之： <strong>一般情况下，如果没有经过特殊处理，移动端浏览器在派发点击事件的时候，通常会出现300ms左右的延迟。</strong></p>
<p><strong>二、解决方案:</strong></p>
<p>1.禁用缩放<br>当HTML文档头部包含如下meta标签时：</p>
<blockquote>
<p> &lt; meta name=”viewport” content=”user-scalable=no” &gt;</p>
<p> &lt; meta name=”viewport” content=”initial-scale=1,maximum-scale=1” &gt;</p>
</blockquote>
<p>表明这个页面是不可缩放的，那双击缩放的功能就没有意义了，此时浏览器可以禁用默认的双击缩放行为并且去掉300ms的点击延迟。<br>这个方案有一个缺点，就是必须通过完全禁用缩放来达到去掉点击延迟的目的，然而完全禁用缩放并不是我们的初衷，我们只是想禁掉默认的双击缩放行为，这样就不用等待300ms来判断当前操作是否是双击。但是通常情况下，我们还是希望页面能通过双指缩放来进行缩放操作，比如放大一张图片，放大一段很小的文字。</p>
<p>2.更改默认的视口宽度</p>
<p>一开始，为了让桌面站点能在移动端浏览器正常显示，移动端浏览器默认的视口宽度并不等于设备浏览器视窗宽度，而是要比设备浏览器视窗宽度大，通常是980px。我们可以通过以下标签来设置视口宽度为设备宽度。</p>
<blockquote>
<p>&lt; meta name=”viewport” content=”width=device-width”&gt;</p>
</blockquote>
<p>因为双击缩放主要是用来改善桌面站点在移动端浏览体验的，而随着响应式设计的普及，很多站点都已经对移动端坐过适配和优化了，这个时候就不需要双击缩放了，如果能够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。如果设置了上述meta标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了。<br>这个方案相比方案一的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。</p>
<p>3.css touch-action</p>
<p>touch-action这个CSS属性。这个属性指定了相应元素上能够触发的用户代理（也就是浏览器）的默认行为。如果将该属性值设置为touch-action: none，那么表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。（对于此方案,IE是支持的，但是其他浏览器支持不完善）</p>
<p>4.FastClick</p>
<p>FastClick是FT Labs 专门为解决移动端浏览器300毫秒点击延迟问题所开发的一个轻量级的库。FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器历史]]></title>
      <url>http://www.skyshu.com/2018/09/18/history/</url>
      <content type="html"><![CDATA[<p><strong>window.history:</strong></p>
<p>DOM window 对象通过 history 对象提供了对浏览器历史的访问。它暴露了很多有用的方法和属性，允许你在用户浏览历史中向前和向后跳转，同时——从HTML5开始——提供了对history栈中内容的操作。</p>
<p><strong>属性</strong></p>
<ul>
<li><p>length：当前窗口的历史记录条数。</p>
</li>
<li><p>scrollRestoration：允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。此属性可以是自动的（auto）或者手动的（manual）。</p>
</li>
<li><p>state：返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate 事件而查看状态而的方式。</p>
</li>
</ul>
<p><strong>方法</strong></p>
<p>1.在history中跳转</p>
<ul>
<li>back()：回到上一条历史记录，与点击浏览器回退按钮的效果相同。</li>
<li>forward()：前往下一条历史记录，与点击浏览器前进按钮的效果相同。</li>
<li>go(num)：前进或回退指定num条历史记录，当num为负数的时候，表示回退num条历史记录，当num为大于0的数时，表示前进num条历史记录。</li>
</ul>
<p>2.添加和修改历史记录中的条目</p>
<p>HTML5引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。这些方法通常与window.onpopstate配合使用。</p>
<p>使用 history.pushState() 可以改变<strong>referrer</strong>，它在用户发送 XMLHttpRequest 请求时在HTTP头部使用，改变state后创建的 XMLHttpRequest 对象的referrer都会被改变。因为referrer是标识创建  XMLHttpRequest 对象时 this 所代表的window对象中document的URL。</p>
<ul>
<li><p>pushstate(state,title,url)：向历史记录中添加一条记录。<br>  pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL.</p>
<ul>
<li>状态对象 — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，<strong>popstate</strong>事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本(进入该条历史可读state)。状态对象可以是能被序列化的任何东西。原因在于Firefox将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 pushState() 方法传了一个序列化后大于640k的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage。</li>
<li>Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。</li>
<li>该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL。</li>
</ul>
</li>
</ul>
<ul>
<li>replaceState(state,title,url)：替换当前历史记录的值，参数与pushstate方法一致。</li>
</ul>
<p><strong>事件:</strong></p>
<p>window.onpopstate是popstate事件在window对象上的事件处理程序。</p>
<p>每当处于激活状态的历史记录条目发生变化时,popstate事件就会在对应window对象上触发. 如果当前处于激活状态(进入)的历史记录条目是由history.pushState()方法创建,或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝.</p>
<p>调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法).</p>
<p>当网页加载时,各浏览器对popstate事件是否触发有不同的表现,Chrome 和 Safari会触发popstate事件, 而Firefox不会.
　　　　　　　　</p>
<p>　　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[加密分析]]></title>
      <url>http://www.skyshu.com/2018/08/21/%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5/</url>
      <content type="html"><![CDATA[<p><strong>1.密钥概念</strong>：</p>
<p>密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。</p>
<p><strong>2.加密方式</strong>: </p>
<p>加密方式分为<strong>对称加密</strong>和<strong>非对称加密</strong>两种。</p>
<p><code>对称加密</code>: 加密使用的密钥和解密使用的密钥是相同的。</p>
<p><code>非对称加密</code>: 加密使用的密钥和解密使用的密钥是不相同的。如公钥密码体制。</p>
<p><strong>3.公钥密码体制</strong>：</p>
<p>以RSA为例，其密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密算法是公开的。由公钥加密的内容可以并且只有由私钥进行解密，并且由私钥加密的内容可以并且只有由公钥进行解密。简而言之，<strong>一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以并且只能由对方进行解密</strong>。</p>
<p><strong>4.数字签名</strong></p>
<p><a href="如果D和D’相同，那么证明M确实是小明发出的，并且没有被篡改过">数字签名详解</a></p>
<p>是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。<br>签名是用于证明消息的真实性。以RSA为例，具体签名过程如下:</p>
<pre><code>1. 发送者对外发布公钥，并声明对应的私钥在自己手上
2. 发送者对消息M计算摘要，得到摘要D
3. 发送者使用私钥对D进行签名，得到签名S
4. 将M和S一起发送出去
</code></pre><p>验证过程如下：</p>
<pre><code>1. 接收者首先对M使用跟发送者一样的摘要算法计算摘要，得到D
2. 使用发送者的公钥对S进行解签，得到D’
3. 如果D和D’相同，那么证明M确实是发送者发出的，并且没有被篡改过
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP缓存]]></title>
      <url>http://www.skyshu.com/2018/08/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p><strong>1.各种类型的缓存:</strong></p>
<p><strong>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</strong>当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>
<p>缓存的种类有很多,其大致可归为两类：<strong>私有(浏览器)与共享(代理)缓存</strong>。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上，为站点和 web 应用提供更好的稳定性、性能和扩展性。</p>
<p><code>(私有)浏览器缓存</code>: 私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。</p>
<p><code>(共享)代理缓存</code>: 共享缓存可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。</p>
<p><strong>2.缓存操作的目标:</strong></p>
<p>常见的 HTTP 缓存只能存储 <strong>GET</strong> 响应，对于其他类型的响应则无能为力。缓存的关键主要包括<strong>request method和目标URI（一般只有GET请求才会被缓存）</strong>。</p>
<p><strong>3.缓存控制:</strong></p>
<p><code>Cache-control头</code>： TTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p>
<h6 id="禁止进行缓存"><a href="#禁止进行缓存" class="headerlink" title="禁止进行缓存"></a>禁止进行缓存</h6><p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p>
<blockquote>
<p>Cache-Control: no-store</p>
<p>Cache-Control: no-cache, no-store, must-revalidate</p>
</blockquote>
<h6 id="强制确认缓存"><a href="#强制确认缓存" class="headerlink" title="强制确认缓存"></a>强制确认缓存</h6><p>如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：<strong>实际就是返回304</strong>），则缓存才使用本地缓存副本。</p>
<h6 id="私有缓存和公有缓存"><a href="#私有缓存和公有缓存" class="headerlink" title="私有缓存和公有缓存"></a>私有缓存和公有缓存</h6><p>“public” 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了”public”，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面），将会被其缓存。</p>
<p>而 “private” 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</p>
<blockquote>
<p>Cache-Control: private</p>
<p>Cache-Control: public</p>
</blockquote>
<p>过期机制中，最重要的指令是 “max-age=<seconds>“，表示资源能够被缓存（保持新鲜）的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。</seconds></p>
<h6 id="缓存验证确认"><a href="#缓存验证确认" class="headerlink" title="缓存验证确认"></a>缓存验证确认</h6><p>当使用了 “must-revalidate” 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。详情看下文关于缓存校验的内容。</p>
<blockquote>
<p>Cache-Control: must-revalidate</p>
</blockquote>
<p><code>Pragma头</code></p>
<p>Pragma 是HTTP/1.0标准中定义的一个header属性，<strong>请求</strong>中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的<strong>响应头</strong>不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设备像素/设备独立像素/css像素之间关系]]></title>
      <url>http://www.skyshu.com/2018/08/14/%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p><strong>分辨率</strong></p>
<p>分辨率可以从显示分辨率与图像分辨率两个方向来分类。</p>
<p>显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指显示器所能显示的像素有多少。</p>
<p>图像分辨率则是单位英寸中所包含的像素点数，其定义更趋近于分辨率本身的定义。</p>
<p>描述<strong>分辨率的单位</strong>有：（dpi点每英寸）、lpi（线每英寸）和ppi（像素每英寸）。但只有lpi是描述光学分辨率的尺度的。虽然dpi和ppi也属于分辨率范畴内的单位，但是他们的含义与lpi不同。而且lpi与dpi无法换算，只能凭经验估算。ppi也是设备像素的单位。</p>
<p><strong>设备像素dp(device pixels)</strong>: 设备像素又称物理像素（physical pixel），设备能控制显示的最小单位。ppi是设备像素dp(device pixels)的单位。</p>
<p>ppi(pixels per inch)表示每英寸所拥有的像素(pixel)数目，数值越高，代表屏幕能以更高的密度显示图像。<br>计算公式：ppi=像素数量/物理尺寸（英寸数）</p>
<p><strong>设备独立像素dips(device-independent pixels)</strong></p>
<p>(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用并控制的虚拟像素(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统转换为物理像素。如：常说的屏幕设备宽高(iphone6:375*667)，可以理解为设备独立像素(或css像素)。比如css的像素单位px,就是基于设备独立像素的。同样100px的大小,在不同设备上展示的大小也是不同的。</p>
<p><strong>CSS像素</strong></p>
<p>CSS像素是Web编程的概念，指的是CSS样式代码中使用的逻辑像素。<br>在CSS规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。<strong>px是一个相对单位，相对的是设备像素(device pixel)。</strong></p>
<p>缩放会引起CSS像素的变化——即引起每1个CSS像素所代表的物理像素变化。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。</p>
<p>所以，有上述描述，我们可以得到如下结论：</p>
<p><strong>页面缩放比例 = 物理像素/CSS像素</strong></p>
<p><strong>设备像素比(dpr)</strong>: 设备像素比，设备像素/设备独立像素，代表设备独立像素到设备像素的转换关系，在JS中可以通过 window.devicePixelRatio获取。</p>
<p>我们要在非标准屏幕上以同样大小显示同一张图片时，就需要缩放图片大小，计算公式为：<br><strong>图片缩放大小 = 图片css大小 * dpr;</strong></p>
<p><strong>viewport的作用</strong></p>
<p><a href="https://blog.csdn.net/lx583274568/article/details/51890095" target="_blank" rel="external">viewport相关概念1</a></p>
<p><a href="https://www.2cto.com/kf/201607/529585.html" target="_blank" rel="external">viewport相关概念2</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[css 布局模式（—）]]></title>
      <url>http://www.skyshu.com/2018/08/08/css%E5%B8%83%E5%B1%80%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><strong>css布局模式</strong>：是一种基于盒子与其兄弟和祖辈盒子的交互方式来确定盒子的位置和大小的算法。有以下几种形式：</p>
<ul>
<li>块布局：用来布置文件。块布局包含以文档为中心的功能，例如 浮动元素或将其放置在多列上的功能。</li>
<li>行内布局：用来布置文本。</li>
<li>表格布局：用来布置表格。</li>
<li>定位布局：用来对那些与其他元素无交互的定位元素进行布置 。</li>
<li><strong>弹性盒子布局</strong>：用来布置那些可以顺利调整大小的复杂页面。</li>
<li><strong>网格布局</strong>：用来布置那些与一个固定网格相关的元素。</li>
</ul>
<p>这里主要对<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes" target="_blank" rel="external"><strong>弹性盒子布局</strong></a>局进行分析。</p>
<p><strong>弹性盒子布局</strong></p>
<p><strong>CSS3 弹性盒子(Flexible Box 或 Flexbox)</strong>，是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测地运行。对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex容器的边缘也不会与其内容的边缘折叠。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[外边距合并]]></title>
      <url>http://www.skyshu.com/2018/08/07/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p><strong>外边距折叠</strong>：块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并。注意浮动元素和绝对定位元素的外边距不会折叠（因为这里触发了 块格式化上下文 Block Formatting Context， BFC）。</p>
<p><strong>相邻元素之间</strong></p>
<p>毗邻的两个元素之间的外边距会折叠（除非后一个元素需要清除之前的浮动, 这也意味着当前两个元素都是浮动元素）。</p>
<p><strong>父元素与其第一个或最后一个子元素之间</strong></p>
<p>如果在父元素与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的 margin-top 分开；或者在父元素与其最后一个子元素之间不存在边框、内边距、行内内容、height、min-height、max-height将两者的 margin-bottom 分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。</p>
<p><strong>空的块级元素</strong></p>
<p>如果一个块级元素中不包含任何内容，并且在其 margin-top 与 margin-bottom 之间没有边框、内边距、行内内容、height、min-height 将两者分开，则该元素的上下外边距会折叠。</p>
<p>一些需要注意的地方：</p>
<ul>
<li>上述情况的组合会产生更复杂的外边距折叠。</li>
<li>即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。</li>
<li>如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和。</li>
<li>如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。</li>
</ul>
<p><strong>如何解决外边距折叠问题</strong></p>
<ol>
<li><p>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（<strong>注意这里指的是上下相邻的元素</strong>）</p>
</li>
<li><p>创建了块级格式化上下文的元素，不和它的子元素发生 margin 折叠（<strong>注意这里指的是创建了BFC的元素和它的子元素不会发生折叠</strong>）</p>
</li>
</ol>
<p>触发<a href=""><strong>BFC因素</strong></a>之前blog已经说明，<strong>很明显可以看出来相邻元素不发生折叠的因素是触发BFC因素的子集，也就是说如果为上下相邻的元素设置了overflow:hidden，虽然触发了BFC，但是上下元素的上下margin还是会发生折叠</strong></p>
<p>要知道BFC不是全能，创建BFC的初衷只是为了让元素本身（包括它的子元素）能够正确的计算自己的宽高。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[层叠上下文]]></title>
      <url>http://www.skyshu.com/2018/08/07/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      <content type="html"><![CDATA[<p><strong>层叠上下文</strong>: HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</p>
<p><strong>层叠上下文形成条件</strong>: </p>
<ul>
<li>根元素 (HTML),</li>
<li>z-index 值不为 “auto”的 绝对/相对定位，</li>
<li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素display: flex|inline-flex，</li>
<li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li>
<li>transform 属性值不为 “none”的元素，</li>
<li>mix-blend-mode 属性值不为 “normal”的元素，</li>
<li>filter值不为“none”的元素，</li>
<li>perspective值不为“none”的元素，</li>
<li>isolation 属性被设置为 “isolate”的元素，</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）</li>
<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>
</ul>
<p>在层叠上下文中，其子元素同样也按照上面解释的规则进行层叠。 特别值得一提的是，其子元素的 z-index 值只在父级层叠上下文中有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。</p>
<p>总结：</p>
<ul>
<li>给一个 HTML 元素定位和 z-index 赋值创建一个层叠上下文，（opacity 值不为 1 的也是相同）。</li>
<li>层叠上下文可以包含在其他层叠上下文中，并且一起创建一个有层级的层叠上下文。</li>
<li>每个层叠上下文完全独立于它的兄弟元素：当处理层叠时只考虑子元素。</li>
<li>每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会 在父层叠上下文中 按顺序进行层叠。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[块格式化上下文（Block Formatting Context，BFC）]]></title>
      <url>http://www.skyshu.com/2018/08/07/BFC/</url>
      <content type="html"><![CDATA[<p><strong>块格式化上下文</strong>：是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p><strong>块格式化上下文生成条件</strong></p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）</li>
<li>overflow 值不为 visible 的块元素（不会与子元素发生外边距折叠）</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content或 strict 的元素</li>
<li>弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li>
<li>网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>
</ul>
<p>创建了块格式化上下文的元素中的所有内容都会被包含到该BFC中。</p>
<p>块格式化上下文对浮动定位与清除浮动都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Function.prototype 的常用属性和方法解读]]></title>
      <url>http://www.skyshu.com/2018/08/06/Function_prototype/</url>
      <content type="html"><![CDATA[<p>此处仅对常用的Funtion原型属性/方法进行分析。</p>
<p><strong>属性</strong></p>
<p><code>Function.arguments</code>:以数组形式获取传入函数的所有参数。<br>补充说明：已定义参数、未定义参数(rest)与arguments关系。相关代码如下：</p>
<pre><code>function foo(a, b, ...rest) {
  console.log(&apos;a = &apos;+ a);
  console.log(&apos;b = &apos;+ a);
  console.log(rest);
  console.log(arguments);
}
foo(1,2,3,4,5);

// result
// a = 1
// b = 2
// Array [3,4,5]
// Array [1,2,3,4,5] 省略内置方法
</code></pre><p><code>Function.prototype.constructor</code>：指定创建对象原型的函数。基于此，亦可用来判断数据类型。</p>
<p><strong>方法</strong></p>
<p><code>Function.prototype.apply()</code>: 在一个对象的上下文中应用另一个对象的方法；参数能够以数组形式传入(参数指调用当前方法，可传入的实参)。</p>
<p><code>Function.prototype.call()</code>: 在一个对象的上下文中应用另一个对象的方法；参数能够以列表形式传入(参数指调用当前方法，可传入的实参)。</p>
<p><strong><a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="external">call()与apply()的实现原理</a></strong></p>
<p>二者简而言之的目的，都是为了使用其他对象的方法。</p>
<p>可分为3个步骤</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<p>以call()为例，实现代码如下：</p>
<pre><code>Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }

    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);

    delete context.fn
    return result;
}

// 测试一下
var value = 2;
var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.call(null); // 2

console.log(bar.call2(obj, &apos;kevin&apos;, 18));
// 1
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>更改方法/函数内部this指向，本质上来说，是给需要使用该方法的对象，临时新增了该方法，并没有改变该方法的原始所属对象。</p>
<p><code>Function.prototype.bind</code>: bind()方法会创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this,传入 bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="external"><strong>bind()的实现原理</strong></a></p>
<p>bind()函数的两个特点:</p>
<ol>
<li>返回一个函数</li>
<li>可以传入参数</li>
</ol>
<p>实现代码如下：</p>
<pre><code>Function.prototype.bind2 = function (context) {

if (typeof this !== &quot;function&quot;) {
  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
}

var self = this;
var args = Array.prototype.slice.call(arguments, 1);

var fNOP = function () {};

var fBound = function () {
    var bindArgs = Array.prototype.slice.call(arguments);
    return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
}

fNOP.prototype = this.prototype;
fBound.prototype = new fNOP();
return fBound;
}
</code></pre><p>apply call bind三者比较：</p>
<ol>
<li><p>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的。</p>
</li>
<li><p>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文。</p>
</li>
<li><p>apply 、 call 、bind 三者都可以利用后续参数传参。</p>
</li>
<li><p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。</p>
</li>
</ol>
<p>代码演示如下：</p>
<pre><code>var obj = {
    x: 81,
};
var foo = {
    getX: function() {
        return this.x;
    }
}
console.log(foo.getX.bind(obj)());  //81
console.log(foo.getX.call(obj));    //81
console.log(foo.getX.apply(obj));   //81

/*
    区别在于, 使用apply()/call(), 改变上下文环境之后,
    会立即执行函数; 而使用bind(), 并非立即执行, 而是回调执行
*/ 
</code></pre><p><code>Function.prototype.toString</code>: 返回一个表示当前函数源代码的字符串。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js之深拷贝与浅拷贝]]></title>
      <url>http://www.skyshu.com/2018/08/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p><strong>基本概念</strong></p>
<p>从指针的角度出发，浅拷贝只是增加了一个指针，指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存。</p>
<p><strong>浅拷贝与深拷贝解读</strong></p>
<p>js包括<strong>基本数据类型</strong>与<strong>引用数据类型</strong>。基本数据类型即 number、string、boolean、null、undefined五类。引用数据类型即 Object、Array、function。</p>
<p>从堆栈关系来说，二者的主要区别在于数据存储的位置不同，基础数据类型值存储在栈区，而引用数据类型值存储在堆区，其地址存储在栈区。</p>
<p>基础数据类型赋值时，会在栈区开辟一块新的内存，将值存储在栈区，以确保赋值与被赋值变量二者的独立性。</p>
<p>引用数据类型赋值时，也会在栈区开辟一块新的内存，不过存储的是值所在的地址(指针)，而值所在的堆区保持不变。赋值与被赋值变量二者存储的地址指向的是同一块堆区内存。通过这种赋值方式，由于使用同一块堆区内存，只要一方的数据发生变化，另一方数据也会随之变化，也将这种赋值称作浅拷贝。若不想产生这种相互干扰，得让双方不共用同一块堆区内存，开辟一块新的堆区内存，以实现深拷贝。由此可以看出浅拷贝与深拷贝是针对引用数据类型进行的。</p>
<p><strong>如何实现深拷贝</strong></p>
<p><strong>1.递归</strong></p>
<p>通过层层递归，可将引用数据类型的赋值，转成基础数据类型的赋值，代码实现如下：</p>
<pre><code>var obj1 = {name:&apos;DDB&apos;,age:18,arr:[1,2,3,4]};
var obj2 = {};
function deepCloneByRecurve(primaryObj,copyObj) {
   var _copyObj = copyObj || {};
   for (var key in primaryObj){
     if(typeof primaryObj[key] === &apos;object&apos;){
       _copyObj[key] = (primaryObj[key].constructor === Array) ? []:{};
       deepCloneByRecurve(primaryObj[key],_copyObj[key]);
     }else {
       _copyObj[key] = primaryObj[key];
     }
   }
   return _copyObj;
}
obj2 = deepCloneByRecurve(obj1,obj2);
obj2.arr.push(5);
console.log(obj1.arr); // [1,2,3,4]
console.log(obj2.arr); // [1,2,3,4,5]
</code></pre><p><strong>2.json</strong></p>
<p>可利用JSON进行深拷贝，代码实现如下：  </p>
<pre><code>var obj1 = {name:&apos;DDB&apos;,age:18,arr:[1,2,3,4]};
var obj3 = {};
function deepCloneByJOSN(primaryObj) {
  return JSON.parse(JSON.stringify(primaryObj));
}
var obj3 = deepCloneByJOSN(obj1);
obj3.arr.push(6);
console.log(obj1.arr); // [1,2,3,4]
console.log(obj3.arr); // [1,2,3,4,6]
</code></pre><p>对于一般的需求是可以满足的，但是它有缺点。下例中，可以看到JSON复制会忽略掉值为undefined以及函数表达式。</p>
<pre><code>var obj = {
  a: 1,
  b: 2,
  c: undefined,
  sum: function() { return a + b; }
};
var obj2 = deepCloneByJOSN(obj);
console.log(obj2);  //Object {a: 1, b: 2}
</code></pre><p><strong>3.针对数组深拷贝的其他实现</strong></p>
<p>3.1 <strong>slice</strong>方法</p>
<p>slice() 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</p>
<p>实现代码如下：</p>
<pre><code>var arr = [1,2,3,4,5];
var arr2 = arr.slice(0);
arr2[2] = 5;
console.log(arr); // [1,2,3,4,5]
console.log(arr2); // [1,2,5,4,5]
</code></pre><p>3.2 <strong>concat</strong>方法</p>
<p>concat() 不会改变现有的数组，而仅仅会返回被连接数组的一个副本（新数组）。</p>
<p>实现代码如下：</p>
<pre><code>var arr = [1,2,3,4,5];
var arr2 = arr.concat();
arr2[2] = 5;
console.log(arr); // [1,2,3,4,5]
console.log(arr2); // [1,2,5,4,5]
</code></pre><p>3.3 ES6的扩展方法 <strong>Array.from / …</strong></p>
<p>1)  <strong>Array.from()</strong> 方法从一个类似数组或可迭代对象中创建一个新的数组实例。</p>
<p>代码实现如下：</p>
<pre><code>var arr1=[1,2,3];
var arr2=Array.from(arr1);
arr2.push(4);
console.log(arr1); // [1,2,3]
console.log(arr2); // [1,2,3,4]
</code></pre><p>2)  <strong>扩展运算符(…)</strong></p>
<p>扩展运算符(spread) 是3个点 (…)。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p>代码实现如下：</p>
<pre><code>var arr1=[1,2,3];
var arr2=[...arr1];
arr2.push(4);
console.log(arr1); // [1,2,3]
console.log(arr2); // [1,2,3,4]
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器探讨(—)]]></title>
      <url>http://www.skyshu.com/2018/08/03/brower/</url>
      <content type="html"><![CDATA[<p><strong>浏览器的主要功能</strong></p>
<p>浏览器的主要功能是通过从服务器请求并在浏览器窗口中显示它来显示您选择的Web资源。资源通常是HTML文档，但也可以是PDF，图像或其他类型的内容。用户使用<strong>URI</strong>（统一资源标识符）指定资源的位置。</p>
<p><strong>浏览器的高级结构</strong></p>
<p>1.<strong>用户界面</strong>：这包括地址栏，后退/前进按钮，书签菜单等。浏览器的每个部分都显示除了您看到所请求页面的窗口。</p>
<p>2.<strong>浏览器引擎</strong>：在UI和呈现引擎之间编组操作。</p>
<p>3.<strong>渲染引擎</strong>：负责显示请求的内容。例如，如果请求的内容是HTML，则呈现引擎解析HTML和CSS，并在屏幕上显示解析的内容。不同的浏览器使用不同的渲染引擎：<strong>Internet Explorer使用Trident，Firefox使用Gecko，Safari使用WebKit。Chrome和Opera（来自15版）使用Blink，一个WebKit的分支</strong>。</p>
<p>4.<strong>网络</strong>：用于网络调用，例如HTTP请求，在独立于平台的界面后面使用不同平台的不同实现。</p>
<p>5.<strong>UI后端</strong>：用于绘制组合框和窗口等基本小部件。此后端公开了一个非平台特定的通用接口。它下面使用操作系统用户界面方法。</p>
<p>6.<strong>JavaScript解释器</strong>：用于解析和执行JavaScript代码。</p>
<p>7.<strong>数据存储</strong>：这是一个持久层。浏览器可能需要在本地保存各种数据，例如cookie。浏览器还支持存储机制，例如localStorage，IndexedDB，WebSQL和FileSystem。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Object.defineProperty]]></title>
      <url>http://www.skyshu.com/2018/08/02/defineProperty/</url>
      <content type="html"><![CDATA[<h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty()</a></h1><hr>
<p><strong>作用</strong> 该方法会直接在一个对象上定义一个新属性, 或者修改一个对象的现有属性, 并返回这个对象。</p>
<p><strong>语法</strong> <code>Object.defineProperty(obj, prop, descriptor)</code></p>
<p><strong>参数</strong>  </p>
<p><code>obj</code>: 要在其上定义属性的对象。</p>
<p><code>prop</code>: 要定义或修改的属性的名称。</p>
<p><code>descriptor</code>: 将被定义或修改的属性描述符。</p>
<p><strong>属性描述符</strong> </p>
<p> 对象里目前存在的属性描述符有两种主要形式<strong>数据描述符</strong>和<strong>存取描述符</strong>。<strong>数据描述符</strong>是一个具有值的属性，该值可能是可写的，也可能不是可写的。<strong>存取描述符</strong>是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。</p>
<p><strong>数据描述符和存取描述符均具</strong>有以下可选键值：</p>
<p><code>configurable</code><br>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</p>
<p><code>enumerable</code> 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</p>
<p><strong>数据描述符同时具有以下可选键值</strong>:</p>
<p><code>value</code>  该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p>
<p><code>writable</code> 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p>
<p><strong>存取描述符同时具有以下可选键值</strong></p>
<p><code>get</code>  一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。</p>
<p><code>set</code>  一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。</p>
]]></content>
    </entry>
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[变量的解构赋值]]></title>
      <url>http://www.skyshu.com/2018/10/22/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      <content type="html"><![CDATA[<p><strong>1.解构概念</strong></p>
<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值</strong>，这被称为解构（Destructuring）。</p>
<p><strong>2.数组的解构赋值</strong></p>
<p>2.1 基本用法</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code>let a = 1;
let b = 2;
let c = 3;
</code></pre><p>ES6 允许写成下面这样。</p>
<pre><code>let [a, b, c] = [1, 2, 3];
</code></pre><p><strong>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</strong> 下面是一些使用嵌套数组进行解构的例子。</p>
<pre><code>let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&apos;a&apos;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<pre><code>let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
</code></pre><p>2.2 默认值</p>
<p>解构赋值允许指定默认值。</p>
<pre><code>let [foo = true] = [];
foo // true

let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;
let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;
</code></pre><p><strong>3.对象解构</strong></p>
<p>解构不仅可以用于数组，还可以用于对象。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ES6下Proxy]]></title>
      <url>http://www.skyshu.com/2018/10/22/Proxy/</url>
      <content type="html"><![CDATA[<p><strong>1.概述</strong></p>
<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre><code>var obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`);
    return Reflect.set(target, key, value, receiver);
  }
});
</code></pre><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。</p>
<pre><code>obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
</code></pre><p>上面代码说明，Proxy <strong>实际上重载（overload）了点运算符</strong>，即用自己的定义覆盖了语言的原始定义(重写setter,getter方法)。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code>var proxy = new Proxy(target, handler);
</code></pre><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，<strong>new Proxy()表示生成一个Proxy实例</strong>，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<pre><code>var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35
</code></pre><p>上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。</p>
<p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p><strong>如果handler没有设置任何拦截，那就等同于直接通向原对象。</strong></p>
<pre><code>var target = {};
var handler = {};
var proxy = new Proxy(target, handler);
proxy.a = &apos;b&apos;;
target.a // &quot;b&quot;
</code></pre><p>上面代码中，handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。</p>
<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<pre><code>var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
</code></pre><p>上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li><p>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</p>
</li>
<li><p>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</p>
</li>
<li><p>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</p>
</li>
<li><p>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</p>
</li>
<li><p>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</p>
</li>
<li><p>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p>
</li>
<li><p>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p>
</li>
<li><p>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</p>
</li>
<li><p>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</p>
</li>
<li><p>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</p>
</li>
<li><p>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
</li>
<li><p>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p>
</li>
<li><p>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p>
</li>
</ul>
<p><strong>2.Proxy 实例的方法</strong></p>
<ul>
<li>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为<strong>目标对象、属性名和 proxy 实例本身</strong>（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</li>
</ul>
<p>get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<p>var person = {<br>  name: “张三”<br>};</p>
<p>var proxy = new Proxy(person, {<br>  get: function(target, property) {<br>    if (property in target) {<br>      return target[property];<br>    } else {<br>      throw new ReferenceError(“Property \”” + property + “\” does not exist.”);<br>    }<br>  }<br>});</p>
<p>proxy.name // “张三”<br>proxy.age // 抛出一个错误</p>
<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。</p>
<ul>
<li>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为<strong>目标对象、属性名、属性值和 Proxy 实例本身</strong>，其中最后一个参数可选。</li>
</ul>
<p>假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。</p>
<pre><code>let validator = {
  set: function(obj, prop, value) {
    if (prop === &apos;age&apos;) {
      if (!Number.isInteger(value)) {
        throw new TypeError(&apos;The age is not an integer&apos;);
      }
      if (value &gt; 200) {
        throw new RangeError(&apos;The age seems invalid&apos;);
      }
    }

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  }
};

let person = new Proxy({}, validator);

person.age = 100;

person.age // 100
person.age = &apos;young&apos; // 报错
person.age = 300 // 报错
</code></pre><p>上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。</p>
<pre><code>const handler = {
  get (target, key) {
    invariant(key, &apos;get&apos;);
    return target[key];
  },
  set (target, key, value) {
    invariant(key, &apos;set&apos;);
    target[key] = value;
    return true;
  }
};
function invariant (key, action) {
  if (key[0] === &apos;_&apos;) {
    throw new Error(`Invalid attempt to ${action} private &quot;${key}&quot; property`);
  }
}
const target = {};
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private &quot;_prop&quot; property
proxy._prop = &apos;c&apos;
// Error: Invalid attempt to set private &quot;_prop&quot; property
</code></pre><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js的垃圾回收机制]]></title>
      <url>http://www.skyshu.com/2018/10/19/js%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><strong>1.垃圾回收机制由来000</strong></p>
<p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。为此系统提供相应的垃圾回收机制。</p>
<p><strong>2.方式</strong></p>
<p>现在各大浏览器通常用采用的垃圾回收有两种方法：<strong>标记清除</strong>、<strong>引用计数</strong>。</p>
<ul>
<li><p><strong>标记清除</strong></p>
<p>  这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p>
<p>  垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<p>  大部分浏览器都是使用这种方式进行垃圾回收，区别在于如何标记及垃圾回收间隔而已，而低版本IE采用的则是<strong>引用计数方式</strong>进行垃圾回收。</p>
</li>
<li><p><strong>引用计数</strong></p>
<p>  引用计数是一种不太常见的垃圾回收方式。</p>
<p>  引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p>
<p>  但这种方式很容易由于循环引用造成内存泄漏。比如对象A有一个属性指向对象B，而对象B也有有一个属性指向对象A，这样相互引用</p>
<pre><code>function test(){
    var objA={};
    var objB={};
    a.prop=b;
    b.prop=a;
}
</code></pre></li>
</ul>
<pre><code>这个例子中，objA和objB通过各自的属性相互引用，也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。      
</code></pre><p>   而在标记清除的策略下是没有问题的，离开环境的就被清除。</p>
<pre><code>我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object 
</code></pre><p>Model，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使IE的Javascript引擎使用标记清除的策略来实现的，但JavaScript访问的COM对象依然是基于引用计数的策略的。说白了，只要IE中涉及COM对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p>
<pre><code>window.onload=function outerFunction(){
    var obj = document.getElementById(&quot;element&quot;);
    obj.onclick=function innerFunction(){};
};
</code></pre><p>上述例子obj引用了document.getElementById(“element”)，而document.getElementById(“element”)的onclick方法会引用外部环境中德变量，自然也包括obj。由于循环引用，也将会造成内存无法回收。</p>
<p>最简单的方式就是自己手工解除循环引用，如下</p>
<pre><code>window.onload=function outerFunction(){
    var obj = document.getElementById(&quot;element&quot;);
    obj.onclick=function innerFunction(){};
   obj=null;
};
</code></pre><p><strong>3.减少JavaScript中的垃圾回收</strong></p>
<p>首先，最明显的，new关键字就意味着一次内存分配，例如 new Foo()。最好的处理方法是：在初始化的时候新建对象，然后在后续过程中尽量多的重用这些创建好的对象。</p>
<p>另外还有以下三种内存分配表达式（可能不像new关键字那么明显了）：</p>
<ul>
<li><p>{} （创建一个新对象）</p>
</li>
<li><p>[] （创建一个新数组）</p>
</li>
<li><p>function() {…} (创建一个有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。新的方法，注意：新建方法也会导致垃圾收集！)</p>
</li>
</ul>
<p><strong>3.1 对象object优化</strong></p>
<p>为了最大限度的实现对象的重用，应该像避使用new语句一样避免使用{}来新建对象。</p>
<p>有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。</p>
<p>cr.wipe(obj)方法就是为此功能而生，代码如下：</p>
<pre><code>// 删除obj对象的所有属性，高效的将obj转化为一个崭新的对象！
cr.wipe = function (obj) {
    for (var p in obj) {
         if (obj.hasOwnProperty(p))
            delete obj[p];
    }
};        
</code></pre><p>有些时候，你可以使用cr.wipe(obj)方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取“新对象”的做法，比简单的通过{}来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！</p>
<p><strong>3.2 数组array优化</strong></p>
<p>将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p>
<p><strong>3.3 方法function优化</strong></p>
<p> 方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。</p>
<p>在游戏的主循环中，setTimeout或requestAnimationFrame来调用一个成员方法是很常见的，例如：</p>
<pre><code>setTimeout(
    (function(self) {                    
      return function () { self.tick();}
    })(this), 16)
</code></pre><p>每过16毫秒调用一次this.tick()，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！为了解决这个问题，可以将作为返回值的方法保存起来，例如:</p>
<pre><code>// at startup
this.tickFunc = (
    function(self) {
      return function() {
                self.tick();
      };
    }
)(this);

// in the tick() function
setTimeout(this.tickFunc, 16);
</code></pre><p>相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[定位简析]]></title>
      <url>http://www.skyshu.com/2018/09/29/%E7%BD%91%E7%BB%9C%E5%AE%9A%E4%BD%8D/</url>
      <content type="html"><![CDATA[<p><strong>定位方式</strong>:<br>定位分为<strong>GPS定位</strong>和<strong>网络定位</strong>2种。</p>
<p>GPS定位: 精度较高，可达到10米，但室内不可用，且超级费电。</p>
<p>网络定位: 分为wifi定位和基站定位，都是通过获取wifi或者基站信息，然后查询对应的wifi或者基站位置数据库，得到的定位地点。定位数据库可以不断完善不断补充，所以，越定位越准确。(常见的浏览器定位，IP定位也是网络定位)。</p>
<p><strong>HTML5地理定位</strong></p>
<p>目前前端采用的主流定位方式是基于H5所提供API进行定位。</p>
<p>H5 Geolocation API定位原理:<br>Geolocation API 是基于新增加的全局对象 navigator：<strong>navigator.geolocation</strong>。JavaScript 对象<br>navigator 包含了很有用的有关访问者的浏览器和系统的信息。<strong>Geolocation 可以使用 IP 地址、基于 Web 的数据库、无线网络连接和三角测量或 GPS 技术来确定经度和纬度。</strong></p>
<p>navigator.geolocation对象说明:</p>
<p><code>方法</code></p>
<ul>
<li><p>getCurrentPosition()</p>
<p>  navigator.geolocation.getCurrentPosition(geolocationSuccess,geolocationError,geolocationOptions);<br>  [geolocationSuccess]– 成功后的回调函数<br>  [geolocationError] – 失败后的回调函数<br>  [geolocationOptions] – 相关配置参数：</p>
<pre><code>enableHighAccuracy – 确保应用会给出最佳结果。
这有可能会让浏览器的反应时间变慢。如果是移动装置，还有可能因
为使用GPS而消耗更多电量。接受参数类型为boolean，默认为false。

timeout – 接受一个数字作为参数，默认为0微秒。设置浏览器的超时时间。 

maximumAge – 表示程序能接受的被缓存位置的最大过期时间。
接受一个数字作为参数，默认为0微秒。这就意味这默认每次获取位置都必需重新获取一个新位置。
</code></pre></li>
</ul>
<ul>
<li><p>watchPosition()<br> watchPosition()方法实现同getCurrentPosition()，区别在于getCurrentPosition() 方法能够获取用户的当前位置，但是只能获取一次。<br> watchPosition() 方法会定期查询用户的位置，观察用户位置是否发生了变化。所以基本上它一直在更新用户的位置。当你在移动的时候，这个功能会非常有利于追踪用户的位置。这个函数还会返回一个watchID值被clearWatch使用来停止监控。</p>
</li>
<li><p>clearWatch()</p>
<p> 这个方法接受一个参数，需要清理的观察进程的id：watchID（这个参数由watchPosition方法返回）。</p>
<pre><code>navigator.geolocation.clearWatch(watchID)
</code></pre></li>
</ul>
<p><code>属性</code></p>
<p>地理位置对象 Position</p>
<p>Geolocation API 的成功函数回调会返回一个地理位置对象 Position。这个对象具有两个属性：timestamp 和 coords。<strong>timestamp</strong> 属性表示地理数据创建的时间。而 <strong>coords</strong> 属性包含了 7 个属性：</p>
<ul>
<li>coords.latitude. 估算的纬度 </li>
<li>coords.longitude. 估算的经度</li>
<li>coords.altitude. 估算的高度 (以米为单位的海拔值) </li>
<li>coords.accuracy. 所得经度和纬度的估算精度，以米为单位 </li>
<li>coords.altitudeAccuracy. 所得高度的估算精度，以米为单位 </li>
<li>coords.heading. 宿主设备的当前移动方向，以度为单位，相对于正北方向顺时针方向计算</li>
<li>coords.speed. 设备的当前对地速度，以米/秒为单位</li>
</ul>
<p>这里只有 3 个属性是必需的：coords.latitude、coords.longitude 和 coords.accuracy。其他属性返回 null，取决于设备及其交互的后端定位服务器的功能。heading 和 speed 属性是基于用户的前一个位置计算的（如果有）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ES6中promise的使用]]></title>
      <url>http://www.skyshu.com/2018/09/29/promise/</url>
      <content type="html"><![CDATA[<p><strong>1.Promise 概念</strong></p>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p><strong>2.基本用法</strong></p>
<p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<pre><code>const promise = new Promise(function(resolve, reject) {
      // ... some code

      if (/* 异步操作成功 */){
        resolve(value);
      } else {
        reject(error);
      }
});
</code></pre><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<pre><code>promise.then(function(value) {
      // success
}, function(error) {
      // failure
});
</code></pre><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<p>举例用Promise对象实现的 Ajax 操作的例子。</p>
<pre><code>const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();
  });
  return promise;
};

getJSON(&quot;/posts.json&quot;).then(function(json) {
  console.log(&apos;Contents: &apos; + json);
}, function(error) {
  console.error(&apos;出错了&apos;, error);
});
</code></pre><p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p><strong>3.原型方法</strong></p>
<p><strong>3.1 Promise.prototype.then()</strong></p>
<p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<p><strong>then方法返回的是一个新的Promise实例</strong>（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<pre><code>getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre><p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log(&quot;resolved: &quot;, comments);
}, function funcB(err){
  console.log(&quot;rejected: &quot;, err);
});
</code></pre><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;resolved: &quot;, comments),
  err =&gt; console.log(&quot;rejected: &quot;, err)
);
</code></pre><p><strong>3.2 Promise.prototype.catch()</strong></p>
<p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<pre><code>getJSON(&apos;/posts.json&apos;).then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&apos;发生错误！&apos;, error);
});
</code></pre><p>上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<pre><code>p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));

// 等同于
p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre><p><strong>3.3 Promise.prototype.finally()</strong></p>
<p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的</p>
<pre><code>promise
.then(result =&gt; {···})
.catch(error =&gt; {···})
.finally(() =&gt; {···});
</code></pre><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。</p>
<pre><code>server.listen(port)
  .then(function () {
    // ...
  })
  .finally(server.stop);
</code></pre><p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p>finally本质上是then方法的特例。</p>
<pre><code>promise
.finally(() =&gt; {
  // 语句
});

// 等同于
promise
.then(
  result =&gt; {
    // 语句
    return result;
  },
  error =&gt; {
    // 语句
    throw error;
  }
);
</code></pre><p>上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。</p>
<p>它的实现也很简单。</p>
<pre><code>Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};
</code></pre><p>上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。</p>
<p>从上面的实现还可以看到，finally方法总是会返回原来的值。</p>
<pre><code>// resolve 的值是 undefined
Promise.resolve(2).then(() =&gt; {}, () =&gt; {})

// resolve 的值是 2
Promise.resolve(2).finally(() =&gt; {})

// reject 的值是 undefined
Promise.reject(3).then(() =&gt; {}, () =&gt; {})

// reject 的值是 3
Promise.reject(3).finally(() =&gt; {})
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[300毫秒延时]]></title>
      <url>http://www.skyshu.com/2018/09/21/300%E6%AF%AB%E7%A7%92/</url>
      <content type="html"><![CDATA[<p><strong>一、问题来源:</strong></p>
<p>这要追溯至 2007 年初。苹果公司在发布首款 iPhone 前夕，遇到一个问题：当时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览桌面端站点的问题。</p>
<p>这当中最出名的，当属双击缩放(double tap to zoom)，这也是会有上述 300 毫秒延迟的主要原因。</p>
<p>双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 那么这和 300 毫秒延迟有什么联系呢？ 假定这么一个场景。用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 鉴于iPhone的成功，其他移动浏览器都复制了 iPhone Safari 浏览器的多数约定，包括双击缩放，几乎现在所有的移动端浏览器都有这个功能。之前人们刚刚接触移动端的页面，在欣喜的时候往往不会care这个300ms的延时问题，可是如今touch端界面如雨后春笋，用户对体验的要求也更高，这300ms带来的卡顿慢慢变得让人难以接受。</p>
<p>简而言之： <strong>一般情况下，如果没有经过特殊处理，移动端浏览器在派发点击事件的时候，通常会出现300ms左右的延迟。</strong></p>
<p><strong>二、解决方案:</strong></p>
<p>1.禁用缩放<br>当HTML文档头部包含如下meta标签时：</p>
<blockquote>
<p> &lt; meta name=”viewport” content=”user-scalable=no” &gt;</p>
<p> &lt; meta name=”viewport” content=”initial-scale=1,maximum-scale=1” &gt;</p>
</blockquote>
<p>表明这个页面是不可缩放的，那双击缩放的功能就没有意义了，此时浏览器可以禁用默认的双击缩放行为并且去掉300ms的点击延迟。<br>这个方案有一个缺点，就是必须通过完全禁用缩放来达到去掉点击延迟的目的，然而完全禁用缩放并不是我们的初衷，我们只是想禁掉默认的双击缩放行为，这样就不用等待300ms来判断当前操作是否是双击。但是通常情况下，我们还是希望页面能通过双指缩放来进行缩放操作，比如放大一张图片，放大一段很小的文字。</p>
<p>2.更改默认的视口宽度</p>
<p>一开始，为了让桌面站点能在移动端浏览器正常显示，移动端浏览器默认的视口宽度并不等于设备浏览器视窗宽度，而是要比设备浏览器视窗宽度大，通常是980px。我们可以通过以下标签来设置视口宽度为设备宽度。</p>
<blockquote>
<p>&lt; meta name=”viewport” content=”width=device-width”&gt;</p>
</blockquote>
<p>因为双击缩放主要是用来改善桌面站点在移动端浏览体验的，而随着响应式设计的普及，很多站点都已经对移动端坐过适配和优化了，这个时候就不需要双击缩放了，如果能够识别出一个网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并且去掉300ms的点击延迟。如果设置了上述meta标签，那浏览器就可以认为该网站已经对移动端做过了适配和优化，就无需双击缩放操作了。<br>这个方案相比方案一的好处在于，它没有完全禁用缩放，而只是禁用了浏览器默认的双击缩放行为，但用户仍然可以通过双指缩放操作来缩放页面。</p>
<p>3.css touch-action</p>
<p>touch-action这个CSS属性。这个属性指定了相应元素上能够触发的用户代理（也就是浏览器）的默认行为。如果将该属性值设置为touch-action: none，那么表示在该元素上的操作不会触发用户代理的任何默认行为，就无需进行300ms的延迟判断。（对于此方案,IE是支持的，但是其他浏览器支持不完善）</p>
<p>4.FastClick</p>
<p>FastClick是FT Labs 专门为解决移动端浏览器300毫秒点击延迟问题所开发的一个轻量级的库。FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器历史]]></title>
      <url>http://www.skyshu.com/2018/09/18/history/</url>
      <content type="html"><![CDATA[<p><strong>window.history:</strong></p>
<p>DOM window 对象通过 history 对象提供了对浏览器历史的访问。它暴露了很多有用的方法和属性，允许你在用户浏览历史中向前和向后跳转，同时——从HTML5开始——提供了对history栈中内容的操作。</p>
<p><strong>属性</strong></p>
<ul>
<li><p>length：当前窗口的历史记录条数。</p>
</li>
<li><p>scrollRestoration：允许Web应用程序在历史导航上显式地设置默认滚动恢复行为。此属性可以是自动的（auto）或者手动的（manual）。</p>
</li>
<li><p>state：返回一个表示历史堆栈顶部的状态的值。这是一种可以不必等待popstate 事件而查看状态而的方式。</p>
</li>
</ul>
<p><strong>方法</strong></p>
<p>1.在history中跳转</p>
<ul>
<li>back()：回到上一条历史记录，与点击浏览器回退按钮的效果相同。</li>
<li>forward()：前往下一条历史记录，与点击浏览器前进按钮的效果相同。</li>
<li>go(num)：前进或回退指定num条历史记录，当num为负数的时候，表示回退num条历史记录，当num为大于0的数时，表示前进num条历史记录。</li>
</ul>
<p>2.添加和修改历史记录中的条目</p>
<p>HTML5引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。这些方法通常与window.onpopstate配合使用。</p>
<p>使用 history.pushState() 可以改变<strong>referrer</strong>，它在用户发送 XMLHttpRequest 请求时在HTTP头部使用，改变state后创建的 XMLHttpRequest 对象的referrer都会被改变。因为referrer是标识创建  XMLHttpRequest 对象时 this 所代表的window对象中document的URL。</p>
<ul>
<li><p>pushstate(state,title,url)：向历史记录中添加一条记录。<br>  pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL.</p>
<ul>
<li>状态对象 — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，<strong>popstate</strong>事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本(进入该条历史可读state)。状态对象可以是能被序列化的任何东西。原因在于Firefox将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有640k的大小限制。如果你给 pushState() 方法传了一个序列化后大于640k的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 sessionStorage 以及 localStorage。</li>
<li>Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。</li>
<li>该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL。</li>
</ul>
</li>
</ul>
<ul>
<li>replaceState(state,title,url)：替换当前历史记录的值，参数与pushstate方法一致。</li>
</ul>
<p><strong>事件:</strong></p>
<p>window.onpopstate是popstate事件在window对象上的事件处理程序。</p>
<p>每当处于激活状态的历史记录条目发生变化时,popstate事件就会在对应window对象上触发. 如果当前处于激活状态(进入)的历史记录条目是由history.pushState()方法创建,或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝.</p>
<p>调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法).</p>
<p>当网页加载时,各浏览器对popstate事件是否触发有不同的表现,Chrome 和 Safari会触发popstate事件, 而Firefox不会.
　　　　　　　　</p>
<p>　　　</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[加密分析]]></title>
      <url>http://www.skyshu.com/2018/08/21/%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5/</url>
      <content type="html"><![CDATA[<p><strong>1.密钥概念</strong>：</p>
<p>密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。</p>
<p><strong>2.加密方式</strong>: </p>
<p>加密方式分为<strong>对称加密</strong>和<strong>非对称加密</strong>两种。</p>
<p><code>对称加密</code>: 加密使用的密钥和解密使用的密钥是相同的。</p>
<p><code>非对称加密</code>: 加密使用的密钥和解密使用的密钥是不相同的。如公钥密码体制。</p>
<p><strong>3.公钥密码体制</strong>：</p>
<p>以RSA为例，其密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密算法是公开的。由公钥加密的内容可以并且只有由私钥进行解密，并且由私钥加密的内容可以并且只有由公钥进行解密。简而言之，<strong>一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以并且只能由对方进行解密</strong>。</p>
<p><strong>4.数字签名</strong></p>
<p><a href="如果D和D’相同，那么证明M确实是小明发出的，并且没有被篡改过">数字签名详解</a></p>
<p>是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。<br>签名是用于证明消息的真实性。以RSA为例，具体签名过程如下:</p>
<pre><code>1. 发送者对外发布公钥，并声明对应的私钥在自己手上
2. 发送者对消息M计算摘要，得到摘要D
3. 发送者使用私钥对D进行签名，得到签名S
4. 将M和S一起发送出去
</code></pre><p>验证过程如下：</p>
<pre><code>1. 接收者首先对M使用跟发送者一样的摘要算法计算摘要，得到D
2. 使用发送者的公钥对S进行解签，得到D’
3. 如果D和D’相同，那么证明M确实是发送者发出的，并且没有被篡改过
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP缓存]]></title>
      <url>http://www.skyshu.com/2018/08/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p><strong>1.各种类型的缓存:</strong></p>
<p><strong>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。</strong>当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>
<p>缓存的种类有很多,其大致可归为两类：<strong>私有(浏览器)与共享(代理)缓存</strong>。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上，为站点和 web 应用提供更好的稳定性、性能和扩展性。</p>
<p><code>(私有)浏览器缓存</code>: 私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。</p>
<p><code>(共享)代理缓存</code>: 共享缓存可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。</p>
<p><strong>2.缓存操作的目标:</strong></p>
<p>常见的 HTTP 缓存只能存储 <strong>GET</strong> 响应，对于其他类型的响应则无能为力。缓存的关键主要包括<strong>request method和目标URI（一般只有GET请求才会被缓存）</strong>。</p>
<p><strong>3.缓存控制:</strong></p>
<p><code>Cache-control头</code>： TTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p>
<h6 id="禁止进行缓存"><a href="#禁止进行缓存" class="headerlink" title="禁止进行缓存"></a>禁止进行缓存</h6><p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p>
<blockquote>
<p>Cache-Control: no-store</p>
<p>Cache-Control: no-cache, no-store, must-revalidate</p>
</blockquote>
<h6 id="强制确认缓存"><a href="#强制确认缓存" class="headerlink" title="强制确认缓存"></a>强制确认缓存</h6><p>如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：<strong>实际就是返回304</strong>），则缓存才使用本地缓存副本。</p>
<h6 id="私有缓存和公有缓存"><a href="#私有缓存和公有缓存" class="headerlink" title="私有缓存和公有缓存"></a>私有缓存和公有缓存</h6><p>“public” 指令表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定了”public”，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面），将会被其缓存。</p>
<p>而 “private” 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</p>
<blockquote>
<p>Cache-Control: private</p>
<p>Cache-Control: public</p>
</blockquote>
<p>过期机制中，最重要的指令是 “max-age=<seconds>“，表示资源能够被缓存（保持新鲜）的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。</seconds></p>
<h6 id="缓存验证确认"><a href="#缓存验证确认" class="headerlink" title="缓存验证确认"></a>缓存验证确认</h6><p>当使用了 “must-revalidate” 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。详情看下文关于缓存校验的内容。</p>
<blockquote>
<p>Cache-Control: must-revalidate</p>
</blockquote>
<p><code>Pragma头</code></p>
<p>Pragma 是HTTP/1.0标准中定义的一个header属性，<strong>请求</strong>中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的<strong>响应头</strong>不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设备像素/设备独立像素/css像素之间关系]]></title>
      <url>http://www.skyshu.com/2018/08/14/%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p><strong>分辨率</strong></p>
<p>分辨率可以从显示分辨率与图像分辨率两个方向来分类。</p>
<p>显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指显示器所能显示的像素有多少。</p>
<p>图像分辨率则是单位英寸中所包含的像素点数，其定义更趋近于分辨率本身的定义。</p>
<p>描述<strong>分辨率的单位</strong>有：（dpi点每英寸）、lpi（线每英寸）和ppi（像素每英寸）。但只有lpi是描述光学分辨率的尺度的。虽然dpi和ppi也属于分辨率范畴内的单位，但是他们的含义与lpi不同。而且lpi与dpi无法换算，只能凭经验估算。ppi也是设备像素的单位。</p>
<p><strong>设备像素dp(device pixels)</strong>: 设备像素又称物理像素（physical pixel），设备能控制显示的最小单位。ppi是设备像素dp(device pixels)的单位。</p>
<p>ppi(pixels per inch)表示每英寸所拥有的像素(pixel)数目，数值越高，代表屏幕能以更高的密度显示图像。<br>计算公式：ppi=像素数量/物理尺寸（英寸数）</p>
<p><strong>设备独立像素dips(device-independent pixels)</strong></p>
<p>(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用并控制的虚拟像素(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统转换为物理像素。如：常说的屏幕设备宽高(iphone6:375*667)，可以理解为设备独立像素(或css像素)。比如css的像素单位px,就是基于设备独立像素的。同样100px的大小,在不同设备上展示的大小也是不同的。</p>
<p><strong>CSS像素</strong></p>
<p>CSS像素是Web编程的概念，指的是CSS样式代码中使用的逻辑像素。<br>在CSS规范中，长度单位可以分为两类，绝对(absolute)单位以及相对(relative)单位。<strong>px是一个相对单位，相对的是设备像素(device pixel)。</strong></p>
<p>缩放会引起CSS像素的变化——即引起每1个CSS像素所代表的物理像素变化。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。</p>
<p>所以，有上述描述，我们可以得到如下结论：</p>
<p><strong>页面缩放比例 = 物理像素/CSS像素</strong></p>
<p><strong>设备像素比(dpr)</strong>: 设备像素比，设备像素/设备独立像素，代表设备独立像素到设备像素的转换关系，在JS中可以通过 window.devicePixelRatio获取。</p>
<p>我们要在非标准屏幕上以同样大小显示同一张图片时，就需要缩放图片大小，计算公式为：<br><strong>图片缩放大小 = 图片css大小 * dpr;</strong></p>
<p><strong>viewport的作用</strong></p>
<p><a href="https://blog.csdn.net/lx583274568/article/details/51890095" target="_blank" rel="external">viewport相关概念1</a></p>
<p><a href="https://www.2cto.com/kf/201607/529585.html" target="_blank" rel="external">viewport相关概念2</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[css 布局模式（—）]]></title>
      <url>http://www.skyshu.com/2018/08/08/css%E5%B8%83%E5%B1%80%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><strong>css布局模式</strong>：是一种基于盒子与其兄弟和祖辈盒子的交互方式来确定盒子的位置和大小的算法。有以下几种形式：</p>
<ul>
<li>块布局：用来布置文件。块布局包含以文档为中心的功能，例如 浮动元素或将其放置在多列上的功能。</li>
<li>行内布局：用来布置文本。</li>
<li>表格布局：用来布置表格。</li>
<li>定位布局：用来对那些与其他元素无交互的定位元素进行布置 。</li>
<li><strong>弹性盒子布局</strong>：用来布置那些可以顺利调整大小的复杂页面。</li>
<li><strong>网格布局</strong>：用来布置那些与一个固定网格相关的元素。</li>
</ul>
<p>这里主要对<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes" target="_blank" rel="external"><strong>弹性盒子布局</strong></a>局进行分析。</p>
<p><strong>弹性盒子布局</strong></p>
<p><strong>CSS3 弹性盒子(Flexible Box 或 Flexbox)</strong>，是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测地运行。对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex容器的边缘也不会与其内容的边缘折叠。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[外边距合并]]></title>
      <url>http://www.skyshu.com/2018/08/07/%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6/</url>
      <content type="html"><![CDATA[<p><strong>外边距折叠</strong>：块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并。注意浮动元素和绝对定位元素的外边距不会折叠（因为这里触发了 块格式化上下文 Block Formatting Context， BFC）。</p>
<p><strong>相邻元素之间</strong></p>
<p>毗邻的两个元素之间的外边距会折叠（除非后一个元素需要清除之前的浮动, 这也意味着当前两个元素都是浮动元素）。</p>
<p><strong>父元素与其第一个或最后一个子元素之间</strong></p>
<p>如果在父元素与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的 margin-top 分开；或者在父元素与其最后一个子元素之间不存在边框、内边距、行内内容、height、min-height、max-height将两者的 margin-bottom 分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。</p>
<p><strong>空的块级元素</strong></p>
<p>如果一个块级元素中不包含任何内容，并且在其 margin-top 与 margin-bottom 之间没有边框、内边距、行内内容、height、min-height 将两者分开，则该元素的上下外边距会折叠。</p>
<p>一些需要注意的地方：</p>
<ul>
<li>上述情况的组合会产生更复杂的外边距折叠。</li>
<li>即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。</li>
<li>如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和。</li>
<li>如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。</li>
</ul>
<p><strong>如何解决外边距折叠问题</strong></p>
<ol>
<li><p>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠（<strong>注意这里指的是上下相邻的元素</strong>）</p>
</li>
<li><p>创建了块级格式化上下文的元素，不和它的子元素发生 margin 折叠（<strong>注意这里指的是创建了BFC的元素和它的子元素不会发生折叠</strong>）</p>
</li>
</ol>
<p>触发<a href=""><strong>BFC因素</strong></a>之前blog已经说明，<strong>很明显可以看出来相邻元素不发生折叠的因素是触发BFC因素的子集，也就是说如果为上下相邻的元素设置了overflow:hidden，虽然触发了BFC，但是上下元素的上下margin还是会发生折叠</strong></p>
<p>要知道BFC不是全能，创建BFC的初衷只是为了让元素本身（包括它的子元素）能够正确的计算自己的宽高。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[层叠上下文]]></title>
      <url>http://www.skyshu.com/2018/08/07/%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      <content type="html"><![CDATA[<p><strong>层叠上下文</strong>: HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。</p>
<p><strong>层叠上下文形成条件</strong>: </p>
<ul>
<li>根元素 (HTML),</li>
<li>z-index 值不为 “auto”的 绝对/相对定位，</li>
<li>一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素display: flex|inline-flex，</li>
<li>opacity 属性值小于 1 的元素（参考 the specification for opacity），</li>
<li>transform 属性值不为 “none”的元素，</li>
<li>mix-blend-mode 属性值不为 “normal”的元素，</li>
<li>filter值不为“none”的元素，</li>
<li>perspective值不为“none”的元素，</li>
<li>isolation 属性被设置为 “isolate”的元素，</li>
<li>position: fixed</li>
<li>在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）</li>
<li>-webkit-overflow-scrolling 属性被设置 “touch”的元素</li>
</ul>
<p>在层叠上下文中，其子元素同样也按照上面解释的规则进行层叠。 特别值得一提的是，其子元素的 z-index 值只在父级层叠上下文中有意义。子级层叠上下文被自动视为父级层叠上下文的一个独立单元。</p>
<p>总结：</p>
<ul>
<li>给一个 HTML 元素定位和 z-index 赋值创建一个层叠上下文，（opacity 值不为 1 的也是相同）。</li>
<li>层叠上下文可以包含在其他层叠上下文中，并且一起创建一个有层级的层叠上下文。</li>
<li>每个层叠上下文完全独立于它的兄弟元素：当处理层叠时只考虑子元素。</li>
<li>每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会 在父层叠上下文中 按顺序进行层叠。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[块格式化上下文（Block Formatting Context，BFC）]]></title>
      <url>http://www.skyshu.com/2018/08/07/BFC/</url>
      <content type="html"><![CDATA[<p><strong>块格式化上下文</strong>：是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p><strong>块格式化上下文生成条件</strong></p>
<ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）</li>
<li>overflow 值不为 visible 的块元素（不会与子元素发生外边距折叠）</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content或 strict 的元素</li>
<li>弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li>
<li>网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>
</ul>
<p>创建了块格式化上下文的元素中的所有内容都会被包含到该BFC中。</p>
<p>块格式化上下文对浮动定位与清除浮动都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Function.prototype 的常用属性和方法解读]]></title>
      <url>http://www.skyshu.com/2018/08/06/Function_prototype/</url>
      <content type="html"><![CDATA[<p>此处仅对常用的Funtion原型属性/方法进行分析。</p>
<p><strong>属性</strong></p>
<p><code>Function.arguments</code>:以数组形式获取传入函数的所有参数。<br>补充说明：已定义参数、未定义参数(rest)与arguments关系。相关代码如下：</p>
<pre><code>function foo(a, b, ...rest) {
  console.log(&apos;a = &apos;+ a);
  console.log(&apos;b = &apos;+ a);
  console.log(rest);
  console.log(arguments);
}
foo(1,2,3,4,5);

// result
// a = 1
// b = 2
// Array [3,4,5]
// Array [1,2,3,4,5] 省略内置方法
</code></pre><p><code>Function.prototype.constructor</code>：指定创建对象原型的函数。基于此，亦可用来判断数据类型。</p>
<p><strong>方法</strong></p>
<p><code>Function.prototype.apply()</code>: 在一个对象的上下文中应用另一个对象的方法；参数能够以数组形式传入(参数指调用当前方法，可传入的实参)。</p>
<p><code>Function.prototype.call()</code>: 在一个对象的上下文中应用另一个对象的方法；参数能够以列表形式传入(参数指调用当前方法，可传入的实参)。</p>
<p><strong><a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="external">call()与apply()的实现原理</a></strong></p>
<p>二者简而言之的目的，都是为了使用其他对象的方法。</p>
<p>可分为3个步骤</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<p>以call()为例，实现代码如下：</p>
<pre><code>Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }

    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);

    delete context.fn
    return result;
}

// 测试一下
var value = 2;
var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.call(null); // 2

console.log(bar.call2(obj, &apos;kevin&apos;, 18));
// 1
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>更改方法/函数内部this指向，本质上来说，是给需要使用该方法的对象，临时新增了该方法，并没有改变该方法的原始所属对象。</p>
<p><code>Function.prototype.bind</code>: bind()方法会创建一个新函数,称为绑定函数.当调用这个绑定函数时,绑定函数会以创建它时传入 bind()方法的第一个参数作为 this,传入 bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="external"><strong>bind()的实现原理</strong></a></p>
<p>bind()函数的两个特点:</p>
<ol>
<li>返回一个函数</li>
<li>可以传入参数</li>
</ol>
<p>实现代码如下：</p>
<pre><code>Function.prototype.bind2 = function (context) {

if (typeof this !== &quot;function&quot;) {
  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
}

var self = this;
var args = Array.prototype.slice.call(arguments, 1);

var fNOP = function () {};

var fBound = function () {
    var bindArgs = Array.prototype.slice.call(arguments);
    return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
}

fNOP.prototype = this.prototype;
fBound.prototype = new fNOP();
return fBound;
}
</code></pre><p>apply call bind三者比较：</p>
<ol>
<li><p>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的。</p>
</li>
<li><p>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文。</p>
</li>
<li><p>apply 、 call 、bind 三者都可以利用后续参数传参。</p>
</li>
<li><p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用。</p>
</li>
</ol>
<p>代码演示如下：</p>
<pre><code>var obj = {
    x: 81,
};
var foo = {
    getX: function() {
        return this.x;
    }
}
console.log(foo.getX.bind(obj)());  //81
console.log(foo.getX.call(obj));    //81
console.log(foo.getX.apply(obj));   //81

/*
    区别在于, 使用apply()/call(), 改变上下文环境之后,
    会立即执行函数; 而使用bind(), 并非立即执行, 而是回调执行
*/ 
</code></pre><p><code>Function.prototype.toString</code>: 返回一个表示当前函数源代码的字符串。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js之深拷贝与浅拷贝]]></title>
      <url>http://www.skyshu.com/2018/08/03/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p><strong>基本概念</strong></p>
<p>从指针的角度出发，浅拷贝只是增加了一个指针，指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存。</p>
<p><strong>浅拷贝与深拷贝解读</strong></p>
<p>js包括<strong>基本数据类型</strong>与<strong>引用数据类型</strong>。基本数据类型即 number、string、boolean、null、undefined五类。引用数据类型即 Object、Array、function。</p>
<p>从堆栈关系来说，二者的主要区别在于数据存储的位置不同，基础数据类型值存储在栈区，而引用数据类型值存储在堆区，其地址存储在栈区。</p>
<p>基础数据类型赋值时，会在栈区开辟一块新的内存，将值存储在栈区，以确保赋值与被赋值变量二者的独立性。</p>
<p>引用数据类型赋值时，也会在栈区开辟一块新的内存，不过存储的是值所在的地址(指针)，而值所在的堆区保持不变。赋值与被赋值变量二者存储的地址指向的是同一块堆区内存。通过这种赋值方式，由于使用同一块堆区内存，只要一方的数据发生变化，另一方数据也会随之变化，也将这种赋值称作浅拷贝。若不想产生这种相互干扰，得让双方不共用同一块堆区内存，开辟一块新的堆区内存，以实现深拷贝。由此可以看出浅拷贝与深拷贝是针对引用数据类型进行的。</p>
<p><strong>如何实现深拷贝</strong></p>
<p><strong>1.递归</strong></p>
<p>通过层层递归，可将引用数据类型的赋值，转成基础数据类型的赋值，代码实现如下：</p>
<pre><code>var obj1 = {name:&apos;DDB&apos;,age:18,arr:[1,2,3,4]};
var obj2 = {};
function deepCloneByRecurve(primaryObj,copyObj) {
   var _copyObj = copyObj || {};
   for (var key in primaryObj){
     if(typeof primaryObj[key] === &apos;object&apos;){
       _copyObj[key] = (primaryObj[key].constructor === Array) ? []:{};
       deepCloneByRecurve(primaryObj[key],_copyObj[key]);
     }else {
       _copyObj[key] = primaryObj[key];
     }
   }
   return _copyObj;
}
obj2 = deepCloneByRecurve(obj1,obj2);
obj2.arr.push(5);
console.log(obj1.arr); // [1,2,3,4]
console.log(obj2.arr); // [1,2,3,4,5]
</code></pre><p><strong>2.json</strong></p>
<p>可利用JSON进行深拷贝，代码实现如下：  </p>
<pre><code>var obj1 = {name:&apos;DDB&apos;,age:18,arr:[1,2,3,4]};
var obj3 = {};
function deepCloneByJOSN(primaryObj) {
  return JSON.parse(JSON.stringify(primaryObj));
}
var obj3 = deepCloneByJOSN(obj1);
obj3.arr.push(6);
console.log(obj1.arr); // [1,2,3,4]
console.log(obj3.arr); // [1,2,3,4,6]
</code></pre><p>对于一般的需求是可以满足的，但是它有缺点。下例中，可以看到JSON复制会忽略掉值为undefined以及函数表达式。</p>
<pre><code>var obj = {
  a: 1,
  b: 2,
  c: undefined,
  sum: function() { return a + b; }
};
var obj2 = deepCloneByJOSN(obj);
console.log(obj2);  //Object {a: 1, b: 2}
</code></pre><p><strong>3.针对数组深拷贝的其他实现</strong></p>
<p>3.1 <strong>slice</strong>方法</p>
<p>slice() 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</p>
<p>实现代码如下：</p>
<pre><code>var arr = [1,2,3,4,5];
var arr2 = arr.slice(0);
arr2[2] = 5;
console.log(arr); // [1,2,3,4,5]
console.log(arr2); // [1,2,5,4,5]
</code></pre><p>3.2 <strong>concat</strong>方法</p>
<p>concat() 不会改变现有的数组，而仅仅会返回被连接数组的一个副本（新数组）。</p>
<p>实现代码如下：</p>
<pre><code>var arr = [1,2,3,4,5];
var arr2 = arr.concat();
arr2[2] = 5;
console.log(arr); // [1,2,3,4,5]
console.log(arr2); // [1,2,5,4,5]
</code></pre><p>3.3 ES6的扩展方法 <strong>Array.from / …</strong></p>
<p>1)  <strong>Array.from()</strong> 方法从一个类似数组或可迭代对象中创建一个新的数组实例。</p>
<p>代码实现如下：</p>
<pre><code>var arr1=[1,2,3];
var arr2=Array.from(arr1);
arr2.push(4);
console.log(arr1); // [1,2,3]
console.log(arr2); // [1,2,3,4]
</code></pre><p>2)  <strong>扩展运算符(…)</strong></p>
<p>扩展运算符(spread) 是3个点 (…)。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p>代码实现如下：</p>
<pre><code>var arr1=[1,2,3];
var arr2=[...arr1];
arr2.push(4);
console.log(arr1); // [1,2,3]
console.log(arr2); // [1,2,3,4]
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器探讨(—)]]></title>
      <url>http://www.skyshu.com/2018/08/03/brower/</url>
      <content type="html"><![CDATA[<p><strong>浏览器的主要功能</strong></p>
<p>浏览器的主要功能是通过从服务器请求并在浏览器窗口中显示它来显示您选择的Web资源。资源通常是HTML文档，但也可以是PDF，图像或其他类型的内容。用户使用<strong>URI</strong>（统一资源标识符）指定资源的位置。</p>
<p><strong>浏览器的高级结构</strong></p>
<p>1.<strong>用户界面</strong>：这包括地址栏，后退/前进按钮，书签菜单等。浏览器的每个部分都显示除了您看到所请求页面的窗口。</p>
<p>2.<strong>浏览器引擎</strong>：在UI和呈现引擎之间编组操作。</p>
<p>3.<strong>渲染引擎</strong>：负责显示请求的内容。例如，如果请求的内容是HTML，则呈现引擎解析HTML和CSS，并在屏幕上显示解析的内容。不同的浏览器使用不同的渲染引擎：<strong>Internet Explorer使用Trident，Firefox使用Gecko，Safari使用WebKit。Chrome和Opera（来自15版）使用Blink，一个WebKit的分支</strong>。</p>
<p>4.<strong>网络</strong>：用于网络调用，例如HTTP请求，在独立于平台的界面后面使用不同平台的不同实现。</p>
<p>5.<strong>UI后端</strong>：用于绘制组合框和窗口等基本小部件。此后端公开了一个非平台特定的通用接口。它下面使用操作系统用户界面方法。</p>
<p>6.<strong>JavaScript解释器</strong>：用于解析和执行JavaScript代码。</p>
<p>7.<strong>数据存储</strong>：这是一个持久层。浏览器可能需要在本地保存各种数据，例如cookie。浏览器还支持存储机制，例如localStorage，IndexedDB，WebSQL和FileSystem。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Object.defineProperty]]></title>
      <url>http://www.skyshu.com/2018/08/02/defineProperty/</url>
      <content type="html"><![CDATA[<h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external">Object.defineProperty()</a></h1><hr>
<p><strong>作用</strong> 该方法会直接在一个对象上定义一个新属性, 或者修改一个对象的现有属性, 并返回这个对象。</p>
<p><strong>语法</strong> <code>Object.defineProperty(obj, prop, descriptor)</code></p>
<p><strong>参数</strong>  </p>
<p><code>obj</code>: 要在其上定义属性的对象。</p>
<p><code>prop</code>: 要定义或修改的属性的名称。</p>
<p><code>descriptor</code>: 将被定义或修改的属性描述符。</p>
<p><strong>属性描述符</strong> </p>
<p> 对象里目前存在的属性描述符有两种主要形式<strong>数据描述符</strong>和<strong>存取描述符</strong>。<strong>数据描述符</strong>是一个具有值的属性，该值可能是可写的，也可能不是可写的。<strong>存取描述符</strong>是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。</p>
<p><strong>数据描述符和存取描述符均具</strong>有以下可选键值：</p>
<p><code>configurable</code><br>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</p>
<p><code>enumerable</code> 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</p>
<p><strong>数据描述符同时具有以下可选键值</strong>:</p>
<p><code>value</code>  该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p>
<p><code>writable</code> 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p>
<p><strong>存取描述符同时具有以下可选键值</strong></p>
<p><code>get</code>  一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。</p>
<p><code>set</code>  一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。</p>
]]></content>
    </entry>
    
  
  
</search>

<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="在小白的路上越走越远">
<meta property="og:type" content="website">
<meta property="og:title" content="DDB Space">
<meta property="og:url" content="http://www.skyshu.com/index.html">
<meta property="og:site_name" content="DDB Space">
<meta property="og:description" content="在小白的路上越走越远">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DDB Space">
<meta name="twitter:description" content="在小白的路上越走越远">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.skyshu.com/"/>





  <title> DDB Space </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">DDB Space</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">另外半只脚印</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/11/16/html_xml_xhtml区别/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/11/16/html_xml_xhtml区别/" itemprop="url">
                  HTML、XML、XHTML区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-16T16:36:51+08:00">
              2018-11-16
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-11-19T11:56:40+08:00">
              2018-11-19
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/11/16/html_xml_xhtml区别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/11/16/html_xml_xhtml区别/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>再说HTML、XML、XHTML区别之前，先了解一下其历史</p>
<p><strong>1.历史</strong></p>
<p>数据标记的需求起源于电子数据格式化。<strong>早期的电子数据格式化主要关注的是数据应该如何被显示而不是数据的文档结构和含义</strong>。Troff(UNIX下的文档资料排版、编辑和格式化程序)和TEX(一种电子排版系统)就是两种早期的格式化语言，在格式化打印文档方面取得了很多成果，但是缺少任何关于结构方面的功能。因此这些文档只局限于屏幕显示和硬拷贝打印。人们难以编写一个程序对这些文档中的信息进行查找、提取和前后对照，更不能方便地将一个文档中的数据重复用于不同的应用中。</p>
<p>　　<strong>通用编码(Generic Coding)使用描述性标签取代格式码</strong>，最终解决上述问题。最早认真研究该问题的是<strong>图形通信协会</strong>(Graphic Communications Association，GCA)。<strong>在20世纪60年代末</strong>，图形通信协会(GCA)的Gen Code委员会<strong>研发出一种使用通用标签(Generic Tag)将不同类型的文档装配成由多个部分组成的复合型文档的方法</strong>。</p>
<p>　　此后，在该方面取得主要进展的是<strong>IBM公司</strong>的一个研发项目：<strong>广义标记语言(Generalized Markup Language，GML)</strong>。由Charles Goldfarb、Edward Mosher和Raymond Lorie三人主持的GML项目旨在提供一个能够在多重信息子系统中使用的文档编码解决方案。因为采用基于内容的标签，由GML编写的文档能够被编辑、格式化以及能够使用不同的程序进行检索。作为一个巨大的技术手册发布者，IBM已经广泛采用了GML，并以此证明了通用编码的生命力。</p>
<p>　　基于GML的成功，<strong>美国国家标准协会</strong>(American National Standards Institute，ANSI)在信息处理方向上建立了一个由Charles Goldfarb领导的项目小组，以研发一个基于GML的文本描述语言标准为目的。GCA的Gen Code委员会也为此项目贡献了力量。自20世纪70年代后期到80年代早期，该委员会发布了工作草案并最终提交了一个工业标准的候选方案(GCA 101-1983)，该候选方案被称为<strong>广义标记语言标准(the Standard Generalized MarkupLanguage，SGML)</strong>。该标准很快就被美国国防部(the U．S． Department of Defense)和美国国内税局(the U．S． Internal Revenue Service)采用。</p>
<p>　　在随后的几年里，SGML得到了世界上更多国家的认可。自1985年以来，世界上的SGML用户群体开始在英国集会。他们协同GCA一起将SGML在欧洲和北美进行推广，将SGML拓展到更广阔的领域。美国出版协会(the Association of American Publishers，AAP)的电子手稿项目(the Electronic Manuscript Project)将SGML标准应用于编制通用文档，如书籍和期刊等。美国国防部为其计算机辅助采集和后勤支持(Computer-Aided Acquisition and Logistic Support，CALS)小组开发基于SGML的应用程序，其中包括一种流行的表格格式文档类型称为CALS表格。<strong>鉴于SGML的成功，国际标准化组织(the International Standards Organization，ISO)采纳了SGML标准(ISO 8879：1986)。</strong></p>
<p>　　SGML被设计为一种灵活的，且无所不包的编码方案。和XML一样，SGML基本上是一个为开发专用化标记语言的工具箱。<strong>但是SGML比起XML来大得多，它具有更加灵活的语法以及更多的深奥参数。SGML过于灵活了，以至于开发一个能处理SGML的程序过于复杂和昂贵，只有那些能够承担得起软件开发以及SGML环境维护所需开销的大型机构才能获得SGML带来的好处</strong>。</p>
<p>　　在20世纪90年代早期，由<strong>欧洲粒子物理研究所的雇员Tim Berners-Lee和Anders Berglund发布了超文本标记语言</strong>，将通用编码革命性地引入到了公共大众的视野中。CERN早在1980开始致力于对SGML的研究和推广，当时就由Anders Berglund开发出一种出版系统用来测试SGML。<strong>随后Tim Berners-Lee和Anders Berglund提出一种支持超级文本的SGML文档，这种文档比SGML文档精简和有效。为该超级文本标记语言编写相应软件更为容易，且更容易对文档进行编码。据此，HTMI。得以由实验室应用迅速推广到全世界。HTML的出现极大地推动了世界范围内的互联网的发展，万维网就是一个主要成果。</strong></p>
<p>　　<strong>然而，HTML在某些方面是一种通用编码的倒退</strong>。第一，HTML为了获得精简编码方式的有效性，而抛弃了通用编码的一些基本原则。例如，通用编码要求一个文档类型能用于任何目的，要求用户编码时应重载标签而不是重新定义特殊目的的标签。第二，HTML中的很多标签是纯粹追求显示效果的，这显然与通用编码的初衷相违背。这种简化的结构很难区分文档的开始部分和结束部分。如今采用HTML编码的文档非常依赖纯格式化以致不能被用作其他目的。虽然HTML有着诸多的问题，但是我们不能抹杀它在标记语言的发展过程中为Web的发展带来飞跃所起到的重要作用。至少，HTML使得全世界的人对电子文档化和资源链接充满了兴趣。</p>
<p>　　<strong>为了回归到理想的通用编码状态，一些人试着改变SGML以适应Web，或者干脆改变Web以适应SGML，不幸的是，这被证实是非常困难的。</strong>SGML是如此的巨大，不可能被塞进小小的Web浏览器中。<strong>所以采用一种更小的，却又能保持SGML通用性的语言是唯一可行的途径，由此，令人兴奋不已的可扩展标记语言诞生了(xml)。</strong></p>
<p><strong>2.什么是SGML</strong>(Standard Generalized Markup Language，即<strong>标准通用标记语言</strong>)</p>
<p>该部分内容非重要内容，了解即可</p>
<p><a href="https://wiki.mbalib.com/wiki/SGML" target="_blank" rel="external">SGML</a>是国际上定义电子文档和内容描述的标准。它源于1969年IBM公司开发的文档描述语言GML，GML主要用来解决不同系统中文档格式不同的问题。后经过多年发展，1986年经ISO批准为国际标准ISO8897，并被称为SGML。</p>
<p>制定SGML的基本思想是把文档的内容与样式分开。在SGML中，标记分两种：一种用来描述文档显示的样式，称为<strong>程序标记</strong>；另一种用来描述文档中语句的用途，称为<strong>描述标记</strong>。<strong>一个SGML文件通常分三个层次：结构、内容和样式。</strong>结构为组织文档的元素提供框架，内容是信息本身，样式控制内容的显示。</p>
<p>SGML的平台无关性、结构化、可扩展等特性，使得它使用范围很广，被许多大型公司用来创建和发布信息。</p>
<p><strong>SGML的构成</strong></p>
<p>SGML文件本身包含3个部分：</p>
<ul>
<li><p>SGML声明(SGML Declaration)。</p>
</li>
<li><p>文档类型定义(Document Type Definition，<strong>DTD</strong>)。</p>
</li>
<li><p>文档实例(Document Instance)。</p>
</li>
</ul>
<p>其中，SGML声明是用来告诉SGML分析器(SGML Parser)在分析该份文件时，所使用的字符集和文件特性。</p>
<p>文件类型定义是用来声明该份文件的结构与语法参数，不同的“文件内容”使用不同的“标记”来描述。在这里所谓“标记”(Tag)是指用一特定符号将信息内容中的某一部分加以注记，而此特定符号就称为“标记”。如“＜”及“＞”都是一种标记。当然标记也可以是任何一小段文字。如“＜NAME＞”与“＜／NAME＞”，而“＜NAME＞Iamstudent＜／NAME＞”则是一段加上标记的字串。</p>
<p>　在SGML标记语言的术语中，“＜keyword”称为起始标记，相对的，“／keyvord＞”则称为结束标记。起始标记与结束标记是否一定要成对，可自行定义，而在起始标记与结束标记两者之间的文字“keyword”称为“元素”。至于文档实例，就是加上标记处理后的文件。</p>
<p><strong>SGML的优缺点</strong></p>
<ol>
<li><p>SGML的优点</p>
<ul>
<li><p>高稳定性<br>　　SGML的ISO 8879是国际标准规范，所以可信度相当高，其规范结构也相当的严谨，此外SGML已使用二十几年了，且自1996以来SGML的规范几乎是未曾变更过，所以SGML是相当成熟的一种通用性标记语言。</p>
</li>
<li><p>高可携性<br>　　SGML文件可以跨平台使用，如可以在不同的计算机硬件或操作系统上被使用，甚至可以被不同的应用软件来使用，因为SGML是一种高稳定性的国际标准，加上已使用二十几年，所以支持其格式的应用软件与相关数据转换技术就多，所以SGML文件可以在各应用领域中被广泛采用，当然其可携性相对就可以提高。</p>
</li>
<li><p>高完整性<br>　　制定SGML时就考虑须满足广泛的使用者，所以其规范制定得相当完整，可以满足不同应用领域使用者的需求，且与SGML搭配使用的家族如HyTime与DSSSL也都是国际标准，如HyTime符合ISO／IEC 10744的标准，主要功能是描述动态文件的一种语言，而DSSSL(Doeument Style Semantic And Specification Language)符合ISO/IEC 10179的标准，其制定目标有两个，一为制定SGML文件显示时的样本形式，另一个是有转换语言的功能。</p>
</li>
</ul>
</li>
<li><p>SGML的缺点</p>
<p> 上面提到SGML有高稳定性与完整性的优点，这可使得SGML可以适用在各类应用领域，但这相对的也是SGML致命的缺点。</p>
<ul>
<li><p>高复杂性</p>
<p>　　由于SGML的高度完整性与稳定性，相对的其复杂性也高，这一点可以说是SGML的主要缺陷，如果使用SGML语法规范来制定DTD中的元素(Element)、属性(Attribute)与内容实体(Entity)，可能需要花上数年的时间才能完全了解其中的标准，可见整个SGML系统是过于完善而变成复杂。</p>
<p>　　不止SGML本身复杂，连同要开发SGML相关软件也变得复杂，就开发SGML剖析器而言，用来检查SGML文件中的控制标记与格式，使用C++来撰写都得发上几万行以上才行咧!</p>
</li>
<li><p>费用昂贵</p>
<p>　　从SGML的高复杂性，其相对衍生出来的就是高费用，先前也提过SGML通常被大企业应用在大量的数据上，在SGML被应用之前必需先制定其文件格式定义DTD，以供使用者能遵循这个DTD中定义的文件结构，但其应用的文件数据通常是复杂的，所以制定该DTD也需花长时间才能完成，所以开发能适用的DTD的费用足相当昂贵的。</p>
</li>
</ul>
</li>
</ol>
<p><strong>SGML的标准体系</strong></p>
<p>　SGML标准的体系可分为三个层次：第一层次是元语言标准——SGML标准；第二层次是基础标准，如：文档样式语义与规范语言标准(DSSSL)等，是该体系的基本标准；第三层次是具体的应用标准，如：<strong>Internet上已广泛应用的HTML等标准</strong>。也就是说，在XML标准出现之前，SGML标准已经形成了完善的体系，并有许多建立于其上的应用系统与应用标准。如图所示。</p>
<p><img src="https://wiki.mbalib.com/w/images/e/e4/SGML%E6%A0%87%E5%87%86%E4%BD%93%E7%B3%BB.jpg" alt=""></p>
<p><strong>SGML的现实问题</strong></p>
<p>SGML在其开发之初，是以作为一种规范性的标准为出发点的，因而重视详尽性，而忽视实用性成了它的致命弱点，可以这样说，SGML从来没有在网络上广泛应用过。具体而言：</p>
<p>　　第一、SGML是一个严格而完整的系统，方便软件应用并不是它的首要任务，所以SGML非常复杂，其复杂程度对于网络上的日常应用简直不可思议；</p>
<p>　　第二、SGML十分庞大，既不容易学，又不容易使用，在计算机上实现十分困难；</p>
<p>　　第三、在SGML中有许多语法语义标准，它们既不方便而且消耗昂贵，这导致开发SGML软件非常昂贵。目前比较便宜的SGML软件之一是Adobe Frame Maker，其标准版本价格为850美元，而Adobe Frame Maker+SGML是以1995美元售出的；</p>
<p>　　第四，种种不足，导致了几个主要的浏览器厂商都明确拒绝支持SGML，这无疑造成了SGML在网上传播的最大障碍。</p>
<p>　　鉴于以上因素，SGML已明显不适用于网络社会的需要，“如何使SGML能成功地运用于网络?”，这一问题已自然而然地提上了议程。1996年8月，GCA(图形通信协会)召集SGML开发者们举行了一次会议，与会者明确表示SGML在某些方面已经落伍了，这些种种不足已经成为了它广泛传播的障碍，讨论的结果认为有必要考虑怎样修补SGML。</p>
<p><strong>2.什么是HTML</strong></p>
<p><strong>超文本标记语言(HTML)起源于标准通用标记语言(SGML)</strong>，由世界上最大的粒子物理研究实验室欧洲核子研究中心CERN(the European Organization for Nuclear Research)于1991年首先提出，是推动Web迅速发展的原动力。在互联网发展的早期，为了在各种网络环境之间、不同文件格式之间进行交流，在SGML基础上，CERN提出了超文本标记语言(Hyper Text Markup Language，HTML)的概念。<strong>HTML是一种用来制作超文本文档的简单标记语言，它定义了一组标记符号(tag)，对文件的内容进行标注，指出内容的输出格式，如字体大小、颜色、背景颜色、表格形式、各部分之间逻辑上的组织等，从而实现了文件格式的标准化。</strong>简单地说，HTMI。文件包含了文档数据和显示样式两部分，其中文档数据是显示在Web浏览器中的数据内容，显示样式则规定了这些内容在浏览器中以何种格式、样子呈现给用户。通过统一使用支持HTMI。的浏览软件，用户可以在任意异构的网络环境中阅读同一个文件，得到相同的显示结果，并可以对文件进行跳跃式阅读，展现了很强的表现力。</p>
<p><strong>HTML的主要版本和发布时间</strong></p>
<p>HTMI主要版本和发布时间如下：</p>
<ol>
<li><p>HTML2．0，Internet工程任务组中的HTML工作组开发完成了HTML2．0，于1996年发布。</p>
</li>
<li><p>HTML3．2，W3C于1997年1月14El将其列为推荐版本，在HTMI2．0标准中添加了诸如字体、表格、Java程序、浮动、上标、下标等特征。</p>
</li>
<li><p>HTML4．0，W3C于1997年12月18Et将其列为推荐版本，第二个稍作修正的HTML4．0版本于1998年12月24Et发布。HTML4．0中最重要的特征是引入了样式表CSS技术。</p>
</li>
<li><p>HTML4．01，W3C于1999年12月24日将其列为推荐版本，是HTMI4．0的升级版本，它对原版本做出了部分修正。</p>
</li>
</ol>
<p>补充说明：html 4.01基于SGML，需要声明DTD。html5不基于SGML，所以不需要引用DTD。html是SGML的一个应用，xml是简化了SGML并用来取代SGML的，xhtml就是html从SGML专用xml语法的结果。</p>
<p><strong>3.什么是XML</strong></p>
<p><strong><a href="https://wiki.mbalib.com/wiki/XML" target="_blank" rel="external">XML</a>(扩展标记语言)是SGML的子集</strong>，其目标是允许普通的SGML在Web上以目前HTML的方式被服务、接收和处理。XML被设计成易于实现，且可在SGML和HTML之间互相操作。后来逐渐用于网络数据的转换和描述。</p>
<p>XML是一种专门在World Wide Web(www)上传递信息的语言，就像HTML(超文本标记语言)一样(自从Web出现以来，HTML已经成为了创建Web页的标准语言)。</p>
<p><strong>4.什么是XHTML</strong></p>
<p><a href="https://en.wikipedia.org/wiki/XHTML" target="_blank" rel="external">XHTML(可扩展超文本标记语言)</a> 是XML标记语言系列的一部分。它反映或扩展了广泛使用的超文本标记语言（HTML）的版本。是一种基于XML的HTML。它提供与HTML相同的功能，但具有与XML文档相同的规则。这些规则处理标记的结构，也是为了将HTML重新格式化为格式良好的XML。</p>
<p><strong>XHTML版本</strong></p>
<ul>
<li><p>XHTML 1.0 是一种SGML定义的HTML语言形式，它具有一些扩展的需求，以便逐渐兼容XML语法。</p>
</li>
<li><p>XHTML 1.1是一种用XML定义的，具备XML形式良好(well-formedness)要求的一种HTML语言。</p>
</li>
<li><p>XHTML 5代表“HTML 5的XML序列化”，是一种HTML5的XML语法，可以在将DOM树序列化回HTML5时使用，并且必须遵守更加严格的XML规则和名称空间。设计 XHTML 5的目的是为了让机器的阅读或数据交换更容易，或者便于比较两个HTML 5文档。 它是与HTML 5标准一起指定的。</p>
</li>
</ul>
<p><strong>与HTML的区别</strong></p>
<ul>
<li>从广义上讲，XML规则要求所有元素都可以通过单独的结束标记或使用自动关闭语法（例如<code>&lt;br/&gt;</code>）来关闭，而HTML语法允许某些元素未被封闭，因为它们总是空的（例如<code>&lt;input&gt;</code>）或它们的结束可以隐含地确定（例如遗漏<code>&lt;p&gt;</code>）。</li>
<li>XML对于元素和属性名称区分大小写，而HTML则不区分大小写。</li>
<li>HTML中省略了HTML中的一些速记特征，例如（1）属性最小化，其中可以省略属性值或它们的引用（例如，<code>&lt;option selected&gt;或者&lt;option selected=selected&gt;</code>，在XML中，这必须)。</li>
<li>关于命名空间和精确解析空格以及某些字符和元素，还有许多其他技术要求。</li>
<li>解析错误的行为不同。XML中的致命解析错误（例如错误的标记结构）导致文档处理中止。</li>
</ul>
<p><strong>5.总结</strong></p>
<ol>
<li>最早期的数据标记源于电子数据格式化，主要目的显示数据</li>
<li>为了脱离这种只可以对文档显示/拷贝打印的局限，可以更灵活的对文档进行操作，开始使用描述性标签取代格式码，<strong>通用编码</strong>开始出现。</li>
<li>随后有了广义标记语言(GML) -&gt; 广义标记语言标准(<strong>SGML</strong>) -&gt; <strong>国际标准化组织(ISO)采纳SGML标准</strong>(ISO 8879：1986)</li>
<li>20世纪90年代，为了在各种网络环境之间、不同文件格式之间进行交流，在SGML基础上，产生了html(超文本标记语言)。（在h5之前的html版本是SGML在应用上的一个具体实例，h5不是）。</li>
<li>然而，HTML在某些方面是一种通用编码的倒退，也具有局限性(编码格式)，为了克服这种局限性，试图回归到通用编码，w3c协会基于SGML创建了xml(可扩展性标记语言)，xml是SGML的子集，为SGML的简化而创建的。</li>
<li>开发XHTML是为了使HTML更具可扩展性，将HTML重新格式化为格式良好的xml，提高与其他数据格式的互操作性。作为一种合理的过渡。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/10/29/进程与线程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/29/进程与线程/" itemprop="url">
                  从浏览器多进程到JS单线程，JS运行机制梳理(转载)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-29T18:45:02+08:00">
              2018-10-29
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-11-14T18:00:26+08:00">
              2018-11-14
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/29/进程与线程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/29/进程与线程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.大纲</strong></p>
<blockquote>
<p>区分进程和线程</p>
<p>浏览器是多进程的</p>
<p>浏览器都包含哪些进程？</p>
<p>浏览器多进程的优势</p>
<p>重点是浏览器内核（渲染进程）</p>
<p>Browser进程和浏览器内核（Renderer进程）的通信过程</p>
<p>梳理浏览器内核中线程之间的关系</p>
<p>GUI渲染线程与JS引擎线程互斥</p>
<p>JS阻塞页面加载</p>
<p>WebWorker，JS的多线程？</p>
<p>WebWorker与SharedWorker</p>
<p>简单梳理下浏览器渲染流程</p>
<p>load事件与DOMContentLoaded事件的先后</p>
<p>css加载是否会阻塞dom树渲染？</p>
<p>普通图层和复合图层</p>
<p>从Event Loop谈JS的运行机制</p>
<p>事件循环机制进一步补充</p>
<p>单独说说定时器</p>
<p>setTimeout而不是setInterval</p>
<p>事件循环进阶：macrotask与microtask</p>
<p>写在最后的话</p>
</blockquote>
<p><strong>2.区分进程和线程</strong></p>
<p>线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：</p>
<ul>
<li><p>进程是一个工厂，工厂有它的独立资源</p>
</li>
<li><p>工厂之间相互独立</p>
</li>
<li><p>线程是工厂中的工人，多个工人协作完成任务</p>
</li>
<li><p>工厂内有一个或多个工人</p>
</li>
<li><p>工人之间共享空间</p>
</li>
</ul>
<p>再完善完善概念：</p>
<ul>
<li><p>工厂的资源 -&gt; 系统分配的内存（独立的一块内存）</p>
</li>
<li><p>工厂之间的相互独立 -&gt; 进程之间相互独立</p>
</li>
<li><p>多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务</p>
</li>
<li><p>工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成</p>
</li>
<li><p>工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</p>
</li>
</ul>
<p>然后再巩固下：</p>
<p>如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。</p>
<center><br><img width="80%" src="https://image-static.segmentfault.com/108/522/1085221355-5a6597253f28a_articlex"><br></center>

<p>所以，应该更容易理解了：<strong>进程是cpu资源分配的最小单位</strong>（系统会给它分配内存）</p>
<p>最后，再用较为官方的术语描述一遍：</p>
<ul>
<li>进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>
<li>线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程) <strong>tips</strong></li>
</ul>
<p>不同进程之间也可以通信，不过代价较大<br>现在，一般通用的叫法：<strong>单线程与多线程</strong>，都是指在<strong>一个进程内</strong>的单和多。（所以核心还是得属于一个进程才行）</p>
<p><strong>3.浏览器是多进程的</strong></p>
<p>理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）</p>
<ul>
<li>浏览器是多进程的</li>
<li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li>
<li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。<br>关于以上几点的验证，请再第一张图：</li>
</ul>
<center><br><img width="80%" src="https://image-static.segmentfault.com/720/857/720857855-5a65972548fa1_articlex"><br></center>

<p>图中打开了Chrome浏览器的多个标签页，然后可以在Chrome的任务管理器中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。<br>感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上</p>
<p>注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了<br>（所以每一个Tab标签对应一个进程并不一定是绝对的）</p>
<p><strong>4.浏览器都包含哪些进程？</strong></p>
<p>知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）</p>
<ol>
<li><strong>Browser进程</strong>：<strong>浏览器的主进程</strong>（负责协调、主控），<strong>只有一个</strong>。作用有：<ul>
<li>负责浏览器界面显示，与用户交互。如前进，后退等</li>
<li>负责各个页面的管理，创建和销毁其他进程</li>
<li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li>
<li>网络资源的管理，下载等</li>
</ul>
</li>
</ol>
<ol>
<li>第三方插件进程：<strong>每种类型的插件对应一个进程</strong>，仅当使用该插件时才创建(如vue devtools)。</li>
</ol>
<ol>
<li>GPU进程：最多一个，用于3D绘制等。</li>
</ol>
<ol>
<li><strong>浏览器渲染进程（浏览器内核）</strong>（Renderer进程，内部是多线程的）：<strong>默认每个Tab页面一个进程</strong>，互不影响。主要作用为页面渲染，脚本执行，事件处理等。</li>
</ol>
<p>强化记忆：<strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</strong></p>
<p>当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图</p>
<p><img src="https://image-static.segmentfault.com/375/898/3758981650-5a659724661e6_articlex" alt=""></p>
<p>另外，可以通过Chrome的更多工具 -&gt; 任务管理器自行验证</p>
<p><strong>5.浏览器多进程的优势</strong></p>
<p>相比于单进程浏览器，多进程有如下优点：</p>
<ul>
<li>避免单个page crash影响整个浏览器</li>
<li>避免第三方插件crash影响整个浏览器</li>
<li>多进程充分利用多核优势</li>
<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>
</ul>
<p>简单点理解：<strong>如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。</strong></p>
<p>当然，内存等资源消耗也会更大，有点空间换时间的意思。</p>
<p><strong>6.重点是浏览器内核（渲染进程）</strong></p>
<p>重点来了，我们可以看到，上面提到了这么多的进程，那么，<strong>对于普通的前端操作来说，最重要的是什么呢</strong>？答案是<strong>渲染进程</strong></p>
<p>可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程</p>
<p><strong>请牢记，浏览器的渲染进程是多线程的</strong>（这点如果不理解，请回头看进程和线程的区分）</p>
<p>终于到了线程这个概念了?，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</p>
<ol>
<li>GUI(图形用户界面)渲染线程<ul>
<li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li>
<li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>
<li>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li>
</ul>
</li>
</ol>
<ol>
<li>JS引擎线程<ul>
<li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li>
<li>JS引擎线程负责解析Javascript脚本，运行代码。</li>
<li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li>
<li>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
</li>
</ol>
<ol>
<li>事件触发线程<ul>
<li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li>
<li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li>
<li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li>
</ul>
</li>
</ol>
<ol>
<li>定时触发器线程<ul>
<li>传说中的setInterval与setTimeout所在线程</li>
<li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li>
<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li>
<li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li>
</ul>
</li>
</ol>
<ol>
<li>异步http请求线程<ul>
<li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li>
</ul>
</li>
</ol>
<p>看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于事件触发线程的，所以如果仅仅是看某个碎片化知识，<br>可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：</p>
<center><br><img src="https://image-static.segmentfault.com/208/433/2084336019-5a65972413011_articlex"><br></center>

<p>再说一点，为什么JS引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计选择了单线程。。。</p>
<p><strong>6. Browser进程和浏览器内核（Renderer进程）的通信过程</strong></p>
<p> 看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，<br>这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。</p>
<p>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：<strong>任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程</strong>，<br>然后在这前提下，看下整个的过程：(简化了很多)</p>
<ul>
<li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程</li>
<li><p>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染</p>
<ul>
<li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li>
<li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li>
<li>最后Render进程将结果传递给Browser进程</li>
</ul>
</li>
<li><p>Browser进程接收到结果并将结果绘制出来</p>
</li>
</ul>
<p>这里绘一张简单的图：（很简化）</p>
<center><br><img src="https://image-static.segmentfault.com/168/527/1685277292-5a65972377cb0_articlex"><br></center>

<p>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。</p>
<p>这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。</p>
<p>如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错</p>
<p><strong>7.梳理浏览器内核中线程之间的关系</strong></p>
<p>到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念</p>
<p><strong>8.GUI渲染线程与JS引擎线程互斥</strong></p>
<p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p>
<p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，<br>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p>
<p><strong>9.JS阻塞页面加载</strong></p>
<p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p>
<p>譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。<br>然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p>
<p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
<p><strong>10.WebWorker，JS的多线程？</strong></p>
<p>前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？</p>
<p>所以，后来HTML5中支持了<strong>Web Worker</strong>。</p>
<p>MDN的官方解释是：</p>
<pre><code>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面

一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 

这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window

因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误
</code></pre><p>这样理解下：</p>
<ul>
<li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li>
<li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li>
</ul>
<p>所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，<br>只待计算出结果后，将结果通信给主线程即可，perfect!</p>
<p>而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p>
<p>其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。</p>
<p><strong>11.WebWorker与SharedWorker</strong></p>
<p>既然都到了这里，就再提一下<strong>SharedWorker</strong>（避免后续将这两个概念搞混）</p>
<ul>
<li><p>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</p>
<ul>
<li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</li>
</ul>
</li>
<li><p>SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</p>
<ul>
<li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</li>
</ul>
</li>
</ul>
<p>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。<strong>SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</strong></p>
<p><strong>12.简单梳理下浏览器渲染流程</strong></p>
<p>本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本）</p>
<p>为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）</p>
<pre><code>- 浏览器输入url，浏览器主进程接管，开一个下载线程，
然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，
随后将内容通过RendererHost接口转交给Renderer进程

- 浏览器渲染流程开始
</code></pre><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p>
<pre><code>1.解析html建立dom树
2.解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）
3.布局render树（Layout/reflow），负责各元素尺寸、位置的计算
4.绘制render树（paint），绘制页面像素信息
5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。
</code></pre><p>所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p>
<p>既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。</p>
<p>这里重绘参考来源中的一张图：（参考来源第一篇）</p>
<center><br><img src="https://image-static.segmentfault.com/137/309/1373095523-5a658fc12f1fd_articlex"><br></center>

<p><strong>13.load事件与DOMContentLoaded事件的先后</strong></p>
<p>上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么？</p>
<p>很简单，知道它们的定义就可以了：</p>
<p>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。<br>(譬如如果有async加载的脚本就不一定完成)</p>
<p>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。<br>（渲染完毕了）</p>
<p>所以，顺序是：<code>DOMContentLoaded -&gt; load</code></p>
<p><strong>14.css加载是否会阻塞dom树渲染？</strong></p>
<p>这里说的是头部引入css的情况</p>
<p>首先，我们都知道：css是由单独的下载线程异步下载的。</p>
<p>然后再说下几个现象：</p>
<ul>
<li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</li>
<li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</li>
</ul>
<p>这可能也是浏览器的一种优化机制。</p>
<p>因为你加载css的时候，可能会修改下面DOM节点的样式，<br>如果css加载不阻塞render树渲染的话，那么当css加载完之后，<br>render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。<br>所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，<br>在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p>
<p><strong>15.普通图层和复合图层</strong></p>
<p>渲染步骤中就提到了<code>composite</code>概念。</p>
<p>可以简单的这样理解，浏览器渲染的图层一般包含两大类：<code>普通图层</code>以及<code>复合图层</code></p>
<p>首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）</p>
<p>其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。</p>
<p>然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源<br>（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p>
<p>可以简单理解下：<strong>GPU中，各个复合图层是单独绘制的，所以互不影响</strong>，这也是为什么某些场景硬件加速效果一级棒</p>
<p>可以<code>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>中看到，黄色的就是复合图层信息</p>
<p>如下图。可以验证上述的说法</p>
<p><img src="https://image-static.segmentfault.com/121/298/121298639-5a65972398326_articlex" alt=""></p>
<p><strong>如何变成复合图层（硬件加速）</strong></p>
<p>将该元素变成一个复合图层，就是传说中的硬件加速技术</p>
<ul>
<li>最常用的方式：<code>translate3d</code>、<code>translateZ</code></li>
<li><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li>
<li><code>will-chang</code>属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</li>
<li><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</li>
<li>其它，譬如以前的flash插件</li>
</ul>
<p><strong>absolute和硬件加速的区别</strong></p>
<p>可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。<br>所以，就算absolute中信息改变时不会改变普通文档流中render树，<br>但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。<br>（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p>
<p>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层<br>（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p>
<p><strong>复合图层的作用？</strong></p>
<p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。</p>
<p>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</p>
<p><strong>硬件加速时请使用index</strong></p>
<p>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染</p>
<p>具体的原理时这样的：<br><strong>webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，<br>那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），<br>会默认变为复合层渲染，如果处理不当会极大的影响性能</strong></p>
<p>简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意</p>
<p>另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：</p>
<p><a href="http://web.jobbole.com/83575/" target="_blank" rel="external">http://web.jobbole.com/83575/</a></p>
<p><strong>16.从Event Loop谈JS的运行机制</strong></p>
<p>到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。</p>
<p>注意，这里不谈<code>可执行上下文</code>，<code>VO</code>，<code>scop chain</code>等概念（这些完全可以整理成另一篇文章了），这里主要是结合<code>Event Loop</code>来谈JS代码是如何执行的。</p>
<p>读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
</ul>
<p>然后再理解一个概念：</p>
<ul>
<li>JS分为同步任务和异步任务</li>
<li>同步任务都在主线程上执行，形成一个执行栈</li>
<li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>
<li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li>
</ul>
<p>看图：</p>
<center><br><img width="80%" src="https://image-static.segmentfault.com/352/134/3521345917-5a659722efdc2_articlex"><br></center>

<p>看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，<br>所以自然有误差。</p>
<p><strong>17.事件循环机制进一步补充</strong></p>
<p>这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《<a href="https://vimeo.com/96425312" target="_blank" rel="external">Help, I’m stuck in an event-loop</a>》）</p>
<center><br><img width="80%" src="https://image-static.segmentfault.com/110/313/1103131299-5a659722e7a98_articlex"><br></center>

<p>上图大致描述就是：</p>
<ul>
<li>主线程运行时会产生执行栈，栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）</li>
<li>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</li>
<li>如此循环</li>
<li>注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件</li>
</ul>
<p><strong>18.单独说说定时器</strong></p>
<p>上述事件循环机制的核心是：<strong>JS引擎线程和事件触发线程</strong></p>
<p>但事件上，里面还有一些隐藏细节，譬如调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？</p>
<p>是JS引擎检测的么？当然不是了。它是由定时器线程控制（因为JS引擎自己都忙不过来，根本无暇分身）</p>
<p><strong>为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</strong></p>
<p>什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p>
<p>譬如:</p>
<pre><code>setTimeout(function(){
    console.log(&apos;hello!&apos;);
}, 1000);
</code></pre><p>这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</p>
<pre><code>setTimeout(function(){
    console.log(&apos;hello!&apos;);
}, 0);

console.log(&apos;begin&apos;);
</code></pre><p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行</p>
<p>注意：</p>
<ul>
<li>执行结果是：先begin后hello!</li>
<li>虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。(不过也有一说是不同浏览器有不同的最小时间设定)</li>
<li>就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有可执行栈内空了后才会主动读取事件队列）</li>
</ul>
<p><strong>19.setTimeout而不是setInterval</strong></p>
<p>用setTimeout模拟定期计时和直接用setInterval是有区别的。</p>
<p>因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差<br>（误差多少与代码执行时间有关）</p>
<p>而setInterval则是每次都精确的隔一段时间推入一个事件<br>（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</p>
<p>而且setInterval有一些比较致命的问题就是：</p>
<p>累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，<br>就会导致定时器代码连续运行好几次，而之间没有间隔。<br>就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）</p>
<ul>
<li>譬如像iOS的webview,或者Safari等浏览器中都有一个特点，在滚动的时候是不执行JS的，如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误（这一块后续有补充，setInterval自带的优化，不会重复添加回调）</li>
<li>而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时</li>
</ul>
<p>所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame</p>
<p><strong>补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。</strong></p>
<p><strong>20.事件循环进阶：macrotask与microtask</strong></p>
<p>这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下），<br>强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：</p>
<p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="external">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p>
<p>上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：</p>
<pre><code>console.log(&apos;script start&apos;);

setTimeout(function() {
    console.log(&apos;setTimeout&apos;);
}, 0);

Promise.resolve().then(function() {
    console.log(&apos;promise1&apos;);
}).then(function() {
    console.log(&apos;promise2&apos;);
});

console.log(&apos;script end&apos;);
</code></pre><p>嗯哼，它的正确执行顺序是这样子的：</p>
<pre><code>script start
script end
promise1
promise2
setTimeout
</code></pre><p>为什么呢？因为Promise里有了一个一个新的概念：<code>microtask</code>(微任务)</p>
<p>或者，进一步，JS中分为两种任务类型：<strong>macrotask(宏任务)</strong>和<strong>microtask(微任务)</strong>，在ECMAScript中，<strong>microtask称为jobs，macrotask可称为task</strong></p>
<p>它们的定义？区别？简单点可以按如下理解：</p>
<ul>
<li><p>macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p>
<ul>
<li>每一个task会从头到尾将这个任务执行完毕，不会执行其它</li>
<li><p>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染</p>
<pre><code>task-&gt;渲染-&gt;task-&gt;...
</code></pre></li>
</ul>
</li>
<li><p>microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务</p>
<ul>
<li>也就是说，在当前task任务后，下一个task之前，在渲染之前</li>
<li>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染</li>
<li>也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）</li>
</ul>
</li>
</ul>
<p>分别很么样的场景会形成macrotask和microtask呢？</p>
<ul>
<li>macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）</li>
<li>microtask：Promise，process.nextTick等</li>
</ul>
<p><strong>补充：在node环境下，process.nextTick的优先级高于Promise</strong>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。</p>
<p>参考：<a href="https://segmentfault.com/q/1010000011914016" target="_blank" rel="external">https://segmentfault.com/q/1010000011914016</a></p>
<p>再根据线程来理解下：</p>
<ul>
<li>macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护</li>
<li>microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</li>
</ul>
<p>所以，总结下运行机制：</p>
<ul>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ul>
<p>如图：</p>
<center><br><img src="https://image-static.segmentfault.com/144/425/144425798-5a659724ab503_articlex"><br></center>

<p>另外，请注意下Promise的<code>polyfill</code>与官方版本的区别：</p>
<ul>
<li>官方版本中，是标准的microtask形式</li>
<li>polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式</li>
<li>请特别注意这两点区别</li>
</ul>
<p>注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），<br>但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p>
<p><strong>20180126补充：使用MutationObserver实现microtask</strong></p>
<p>MutationObserver可以用来实现microtask<br>（它属于microtask，优先级小于Promise，<br>一般是Promise不支持时才会这样做）</p>
<p>它是HTML5中的新特性，作用是：监听一个DOM变动，<br>当DOM对象树发生任何变动时，Mutation Observer会得到通知</p>
<p>像以前的Vue源码中就是利用它来模拟nextTick的，<br>具体原理是，创建一个TextNode并监听内容变化，<br>然后要nextTick的时候去改一下这个节点的文本内容，<br>如下：（Vue的源码，未修改）</p>
<pre><code>var counter = 1
var observer = new MutationObserver(nextTickHandler)
var textNode = document.createTextNode(String(counter))

observer.observe(textNode, {
    characterData: true
})
timerFunc = () =&gt; {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
}
</code></pre><p><a href="https://github.com/vuejs/vue/blob/9cfd63a7d08c1eba029c8bd7463b3047c3347826/src/core/util/env.js#L86-L95" target="_blank" rel="external">对应Vue源码链接</a></p>
<p>不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因），<br>取而代之的是使用MessageChannel<br>（当然，默认情况仍然是Promise，不支持才兼容的）。</p>
<p>MessageChannel属于宏任务，优先级是：MessageChannel-&gt;setTimeout，<br>所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。</p>
<p>这里不展开，可以看下<a href="https://juejin.im/post/5a1af88f5188254a701ec230" target="_blank" rel="external">https://juejin.im/post/5a1af88f5188254a701ec230</a></p>
<p><strong>21.写在最后的话</strong><br>    该blog是我转载一个同年龄阶层人所写，看后收货很多，感慨也很深，差距确实很大。这里对自己学习认知上做个简要总结：</p>
<ul>
<li>获取知识的途径很重要，要多结识比自己优秀的人。</li>
<li>学习方式很重要，要学会系统化的学习(T)。</li>
<li>学习态度也很重要，要沉下心搞技术，不然一直会游离在技术的边缘。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/10/24/cordova基础/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/24/cordova基础/" itemprop="url">
                  Cordova之创建APP
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-24T14:51:26+08:00">
              2018-10-24
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-10-24T15:35:46+08:00">
              2018-10-24
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/24/cordova基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/24/cordova基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.概述</strong></p>
<p>Apache Cordova是一个开源的移动开发框架。允许用标准的web技术-HTML5,CSS3和JavaScript做跨平台开发。 应用在每个平台的具体执行被封装了起来，并依靠符合标准的API绑定去访问每个设备的功能，比如说：传感器、数据、网络状态等。</p>
<p>使用Apache Cordova的人群:</p>
<ul>
<li><p>移动应用开发者，想扩展一个应用的使用平台，而不通过每个平台的语言和工具集重新实现。</p>
</li>
<li><p>web开发者，想包装部署自己的web App将其分发到各个应用商店门户。</p>
</li>
<li><p>移动应用开发者，有兴趣混合原生应用组建和一个WebView(一个特别的浏览器窗口) 可以接触设备A级PI，或者你想开发一个原生和WebView组件之间的插件接口。</p>
</li>
</ul>
<p><strong>2.安装</strong></p>
<p>安装cordova命令行工具，通过下面这些步骤:</p>
<ol>
<li><p>下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm 。</p>
</li>
<li><p>(可选)下载和安装git client, 如果你没有。安装成功后，你可以在命令行中使用git。 这个命令行使用下载git仓库中的资源。</p>
</li>
<li><p>安装cordova 模块使用Nodejs的npm工具。cordova模块会被npm工具自动下载。</p>
</li>
</ol>
<ul>
<li><p>在OS X和Linux上:</p>
<pre><code>$ sudo npm install -g cordova
</code></pre><p>  在OS X和Linux上, npm命令加上前缀sudo因为cordova可能需要安装在其他的受限制目录比如 /usr/local/share。如果你使用可选工具nvm/nave或者具有安装目录的写权限，那么你可以省略sudo前缀。这里有更多提示 可用在使用 npm 没有 sudo前缀时，如果你想那么做。</p>
</li>
</ul>
<ul>
<li><p>在Windows上:</p>
<pre><code>C:\&gt;npm install -g cordova
</code></pre><p>  -g标志是告诉 npm 我们全局安装 cordova。否则我们将会安装在当前工作目录的 node_modules子目录。安装完成后，你应该能够在命令行中运行cordova命令，在没有任何参数的时候会打印一些帮助信息。</p>
</li>
</ul>
<p><strong>3.创建App</strong></p>
<p>跳转到你维护源代码的目录中，并创建你的cordova项目：</p>
<pre><code>$ cordova create hello com.example.hello HelloWorld
</code></pre><p>这将会为你的cordova应用创造必须的目录。默认情况下，cordova create命令生成基于web的应用程序的骨骼，项目的主页是 www/index.html 文件。<br>cordova create 到底做了些什么？根据官方描述该命令支持四个参数：</p>
<ol>
<li><strong>path</strong>：也就是项目的目录名称</li>
<li><strong>ID</strong>：项目的ID，用于写入config.xml的widget中，通常格式为 com.example.hello</li>
<li><strong>name</strong>：应用程序的显示名称</li>
<li><strong>options</strong>：项目的可选配置项<ul>
<li>–template：可执行项目的模版文件</li>
<li>–copy-from 指定src</li>
<li>–link-to 可将一个前端资源目录链接到项目的www目录下而不是一个副本</li>
</ul>
</li>
</ol>
<p><strong>通过部分 Cordova cli 源码我们可以大致知道Cordova是如何帮我们创建一个初始化工程的</strong></p>
<pre><code>var paths = {};
//从 cordova-app-hello-world npm包中获取config.xml文件
paths.configXml = path.join(require(&apos;cordova-app-hello-world&apos;).dirname, &apos;config.xml&apos;);
//从 cordova-app-hello-world npm包中获取 www 目录
paths.www = path.join(require(&apos;cordova-app-hello-world&apos;).dirname, &apos;www&apos;);
//从 cordova-app-hello-world npm包中获取 hooks 目录
paths.hooks = path.join(require(&apos;cordova-app-hello-world&apos;).dirname, &apos;hooks&apos;);
// 从 cordova-app-hello-world npm包中获取 package.json 文件
var dirAlreadyExisted = fs.existsSync(dir);//dir为 cordova create 的第一个参数 ptah
//判断当前path是否存在不存在直接创建
if (!dirAlreadyExisted) {
    fs.mkdirSync(dir);
}
try {
    //如果指定了 --template 则从模版复制项目到新项目下 
    if (cfg.lib.www.template) { copyTemplateFiles(import_from_path, dir, isSubDir); }
    //如果指定了 --link 则创建链接到项目
    if (cfg.lib.www.link) { linkFromTemplate(import_from_path, dir); }
    //如果没有没有指定 --template 或者 --link 则直接用 cordova-app-hello-world npm包
    copyIfNotExists(paths.www, path.join(dir, &apos;www&apos;));
    copyIfNotExists(paths.hooks, path.join(dir, &apos;hooks&apos;));
    var configXmlExists = projectConfig(dir); // moves config to root if in www
    if (paths.configXml &amp;&amp; !configXmlExists) {
        shell.cp(paths.configXml, path.join(dir, &apos;config.xml&apos;));
    }
} catch (e) {
    if (!dirAlreadyExisted) {
        shell.rm(&apos;-rf&apos;, dir);
    }
    if (process.platform.slice(0, 3) === &apos;win&apos; &amp;&amp; e.code === &apos;EPERM&apos;) {
        throw new CordovaError(&apos;Symlinks on Windows require Administrator privileges&apos;);
    }
    throw e;
}
//获取 package.json 文件
var pkgjsonPath = path.join(dir, &apos;package.json&apos;);
// Update package.json name and version fields
if (fs.existsSync(pkgjsonPath)) {
    delete require.cache[require.resolve(pkgjsonPath)];
    var pkgjson = require(pkgjsonPath);

    //指定项目名称，也就是我们 cordova create 命令的第三个参数
    if (cfg.name) {
        pkgjson.displayName = cfg.name;
    }
    //指定项目ID，也就是我们 cordova create 命令的第二个参数
    if (cfg.id) {
        pkgjson.name = cfg.id.toLowerCase();
    } else if (!cfg.id) {
        //设置默认ID为 helloworld
        pkgjson.name = &apos;helloworld&apos;;
    }
    pkgjson.version = &apos;1.0.0&apos;;
    fs.writeFileSync(pkgjsonPath, JSON.stringify(pkgjson, null, 4), &apos;utf8&apos;);
}
//创建 platforms(后期添加的Android和iOS平台都放在此文件夹) 和 plugins(插件)文件夹 
if (!fs.existsSync(path.join(dir, &apos;platforms&apos;))) { shell.mkdir(path.join(dir, &apos;platforms&apos;)); }
if (!fs.existsSync(path.join(dir, &apos;plugins&apos;))) { shell.mkdir(path.join(dir, &apos;plugins&apos;)); }
var configPath = path.join(dir, &apos;config.xml&apos;);
// only update config.xml if not a symlink
if (!fs.lstatSync(configPath).isSymbolicLink()) {
    // Write out id and name to config.xml; set version to 1.0.0 (to match package.json default version)
    var conf = new ConfigParser(configPath);
    if (cfg.id) conf.setPackageName(cfg.id);
    if (cfg.name) conf.setName(cfg.name);
    conf.setVersion(&apos;1.0.0&apos;);
    conf.write();
}
</code></pre><p>项目创建成功之后我们将得到如下目录结构</p>
<pre><code>hello/
|-- config.xml      #项目配置文件
|-- hooks/          #存放Cordova 的钩子
|-- node_modules/
|-- res/            #存放一些各平台的icon或者首屏图等资源
|-- www/            #静态网页资源
|-- platforms/      #各平台存放目录
|-- plugins/        #插件目录
|-- package.json
</code></pre><p><strong>4.添加平台</strong></p>
<p>所有后续命令都需要在项目目录或者项目目录的任何子目录运行:</p>
<pre><code>$ cd hello
</code></pre><p>为App添加目标平台。此处添加’android’平台，并确保其保存在了config.xml中:</p>
<pre><code>$ cordova platform add android --save
</code></pre><p>检查你当前平台设置状况:</p>
<pre><code>$ cordova platform ls
</code></pre><p>若成功添加Android平台，当前项目显示如下</p>
<pre><code>Installed platforms:
  android 7.0.0
Available platforms: 
  browser ~5.0.1
  ios ~4.5.4
  osx ~4.0.1
  windows ~5.0.0
  www ^3.12.0
</code></pre><p><strong>注意添加平台先决条件，需要为当前平台配置环境，安装平台所需的SDK。</strong> 除添加browser平台，它不需要任何平台SDK。<br>检测你是否满足构建平台的要求:</p>
<pre><code>$ cordova requirements
</code></pre><p>以Android为例，若平台环境安装好，显示如下：</p>
<pre><code>Requirements check results for android:
Java JDK: installed .
Android SDK: installed
Android target: installed android-19,android-21,android-22,android-23,Google Inc.:Google APIs:19,Google Inc.:Google APIs (x86 System Image):19,Google Inc.:Google APIs:23
Gradle: installed
</code></pre><p>以iOS为例，如平台环境未安装好，显示如下：</p>
<pre><code>Requirements check results for ios:
Apple OS X: not installed
Cordova tooling for iOS requires Apple OS X
Error: Some of requirements check failed
</code></pre><hr>
<p><strong>详细参见如下：</strong></p>
<ul>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/android/index.html#requirements-and-support" target="_blank" rel="external">Android平台的要求</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/ios/index.html#requirements-and-support" target="_blank" rel="external">iOS平台的要求</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/win8/index.html#requirements-and-support" target="_blank" rel="external">Windows平台的要求</a></li>
</ul>
<p><strong>5.构建App</strong></p>
<p>默认情况下, cordova create生产基于web应用程序的骨架，项目开始页面位于www/index.html 文件。任何初始化任务应该在www/js/index.js文件中的deviceready事件的事件处理函数中。</p>
<p>运行下面命令为所有添加的平台构建:</p>
<pre><code>$ cordova build
</code></pre><p>你可以在每次构建中选择限制平台范围 - 这个例子中是’android’:</p>
<pre><code>$ cordova build android
</code></pre><p><strong>6.测试App</strong></p>
<p>移动平台的SDK通常会绑定模拟器，它是一个可执行的设备镜像，这样你就可以在主屏幕启动你的App，看看它在多个平台是如何交互的。 在命令行运行下面的命令，会重新构建App并可以在特定平台的模拟器上查看:</p>
<pre><code>$ cordova emulate android
</code></pre><p>或者，你可以将你的手机插入电脑，在手机上直接测试App:</p>
<pre><code>$ cordova run android
</code></pre><p>在运行命令之前，你需要设置用于测试的设备，以下是每个平台的流程。</p>
<hr>
<p><strong>详细参见如下：</strong></p>
<ul>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/android/index.html#setting-up-an-emulator" target="_blank" rel="external">设置Android模拟器</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-cli/index.html#cordova-run-command" target="_blank" rel="external">Cordova run 命令参考文档</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-cli/index.html#cordova-emulate-command" target="_blank" rel="external">Cordova emulate 命令参考文档</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/10/23/原型链/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/23/原型链/" itemprop="url">
                  原型链(—)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-23T16:35:01+08:00">
              2018-10-23
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-10-24T10:56:55+08:00">
              2018-10-24
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/23/原型链/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/23/原型链/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.由来</strong>：</p>
<p>想象一个这种情况，2个对象，大部分内容都一样，只有一小部分不一样，很明显，在一个好的设计模式中，我们会需要重用那部分相同的，而不是在每个对象中重复定义那些相同的方法或者属性。在基于类[class-based]的系统中，这些重用部分被称为类的继承 – 相同的部分放入class A，然后class B和class C从A继承，并且可以声明拥有各自的独特的东西。</p>
<p>ECMAScript没有类的概念。但是，重用[reuse]这个理念没什么不同（某些方面，甚至比class-更加灵活），可以由prototype chain原型链来实现。这种继承被称为delegation based inheritance-基于继承的委托，或者更通俗一些，叫做原型继承。</p>
<p>类似于类”A”，”B”，”C”，在ECMAScript中尼创建对象类”a”，”b”，”c”，相应地， 对象“a” 拥有对象“b”和”c”的共同部分。同时对象“b”和”c”只包含它们自己的附加属性或方法。</p>
<pre><code>var a = {
     x: 10,
     calculate: function (z) {
   return this.x + this.y + z
     }
};

var b = {
  y: 20,
  __proto__: a
};

var c = {
  y: 30,
  __proto__: a
};

// 调用继承过来的方法
b.calculate(30); // 60
c.calculate(40); // 80
</code></pre><p>如果在对象b中找不到calculate方法(也就是对象b中没有这个calculate属性), 那么就会沿着原型链开始找。如果这个calculate方法在b的prototype中没有找到，那么就会沿着原型链找到a的prototype，一直遍历完整个原型链。记住，一旦找到，就返回第一个找到的属性或者方法。因此，第一个找到的属性成为继承属性。如果遍历完整个原型链，仍然没有找到，那么就会返回undefined。</p>
<p><strong>2.prototype、<strong>proto</strong>、Object、Function关系</strong></p>
<p>prototype: 每一个函数对象都有一个显示的prototype属性,它代表了对象的原型。</p>
<p><strong>proto</strong>:每个对象都有一个名为proto的内部隐藏属性，指向于它所对应的原型对象。</p>
<p>具体如下：</p>
<pre><code>function Animal(){

}
var  anim = new Animal();

console.log(&apos;***********Animal anim proto*****************&apos;);
console.log(&apos;typeof Animal.prototype:&apos; +typeof Animal.prototype);  //object 
console.log(&apos;anim.__proto__===Animal.prototype:&apos;+(anim.__proto__===Animal.prototype));  //true
console.log(&apos;Animal.__proto__===Function.prototype:&apos;+(Animal.__proto__===Function.prototype));  //true
console.log(&apos;Animal.prototype.__proto__===Object.prototype:&apos;+(Animal.prototype.__proto__===Object.prototype));  //true

console.log(&apos;***********Function proto*****************&apos;);
console.log(&apos;typeof Function.prototype:&apos;+typeof Function.prototype);  //function
console.log(&apos;typeof Function.__proto__:&apos;+typeof Function.__proto__);  //function
console.log(&apos;typeof Function.prototype.prototype:&apos;+typeof Function.prototype.prototype); //undefined
console.log(&apos;typeof Function.prototype.__proto__:&apos;+typeof Function.prototype.__proto__);   //object
console.log(&apos;Function.prototype===Function.__proto__:&apos;+(Function.prototype===Function.__proto__)); //true

console.log(&apos;***********Object proto*****************&apos;);
console.log(&apos;typeof Object.prototype:&apos;+typeof Object.prototype);  //object
console.log(&apos;typeof Object.__proto__:&apos;+typeof Object.__proto__);  //function
console.log(&apos;Object.prototype.prototype:&apos;+Object.prototype.prototype);  //undefied
console.log(&apos;Object.prototype.__proto__===null:&apos;+(Object.prototype.__proto__===null));  //null

console.log(&apos;***********Function Object  proto关系*****************&apos;);
console.log(&apos;Function.prototype===Object.__proto__:&apos;+(Function.prototype===Object.__proto__));   //true
console.log(&apos;Function.__proto__===Object.__proto__:&apos;+(Function.__proto__===Object.__proto__));   //true
console.log(&apos;Function.prototype.__proto__===Object.prototype:&apos;+(Function.prototype.__proto__===Object.prototype));   //true

/********************* 系统定义的对象Array、Date ****************************/
console.log(&apos;**************test Array、Date****************&apos;);      
var array = new Array();
var date = new Date();
console.log(&apos;array.__proto__===Array.prototype:&apos;+(array.__proto__===Array.prototype));   //true
console.log(&apos;Array.__proto__===Function.prototype:&apos;+(Array.__proto__===Function.prototype));  //true
console.log(&apos;date.__proto__===Date.prototype:&apos;+(date.__proto__===Date.prototype));    //true
console.log(&apos;Date.__proto__===Function.prototype:&apos;+(Date.__proto__===Function.prototype));     //true
</code></pre><p>所有对象，包括函数对象的原型链最终都指向了Object.prototype，而Object.prototype.proto===null，原型链至此结束。<br>Animal.prototype是一个普通对象。<br>Object是一个函数对象，也是Function构造的，Object.prototype是一个普通对象。<br>Object.prototype.type指向null。<br>Function.prototype是一个函数对象，前面说函数对象都有一个显示的prototype属性，但是Function.prototype却没有prototype属性，即Function.prototype.prototype===undefined，所有Function.prototype函数对象是一个特例，没有prototype属性。<br>Object虽是Function构造的一个函数对象，但是Object.prototype没有指向Function.prototype，即Object.prototype!==Function.prototype。</p>
<p><strong>3.Prototype跟Constructor关系</strong></p>
<p>在 JavaScript 中，每个函数对象都有名为“prototype”的属性(上面提到过Function.prototype函数对象是个例外，没有prototype属性)，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用（i.e. Animal.prototype.constructor===Animal）。</p>
<pre><code>console.log(&apos;anim.constructor===Animal:&apos;+(anim.constructor===Animal))    ;    //true
console.log(&apos;Animal===Animal.prototype.constructor:&apos;+(Animal===Animal.prototype.constructor))    ;    //true
console.log(&apos;Animal.constructor===Function.prototype.constructor:&apos;+(Animal.constructor===Function.prototype.constructor));   //true
console.log(&apos;Function.prototype.constructor===Function:&apos;+(Function.prototype.constructor===Function));    //true
console.log(&apos;Function.constructor===Function.prototype.constructor:&apos;+(Function.constructor===Function.prototype.constructor));    //true
console.log(&apos;Object.prototype.constructor===Object:&apos;+(Object.prototype.constructor===Object));    //true
console.log(&apos;Object.constructor====Function:&apos;+(Object.constructor===Function));    //true
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/10/23/单例模式/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/23/单例模式/" itemprop="url">
                  单例模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-23T16:03:42+08:00">
              2018-10-23
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-10-24T10:55:59+08:00">
              2018-10-24
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/23/单例模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/23/单例模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.概念</strong></p>
<p>单例是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。(在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。）</p>
<p><strong>2.实现与使用场景</strong></p>
<p>2.1 使用对象字面量的方法实现，其字面量里可以包含大量的属性和方法: </p>
<pre><code>var mySingleton = {
property1: &quot;something&quot;,
property2: &quot;something else&quot;,
method1: function () {
    console.log(&apos;hello world&apos;);
}
};
</code></pre><p>要扩展该对象，可以添加私有成员和方法，然后使用闭包在其内部封装这些变量和函数声明。只暴露public成员和方法，样例代码如下：</p>
<pre><code>var mySingleton = function () {

/* 这里声明私有变量和方法 */
var privateVariable = &apos;something private&apos;;
function showPrivate() {
    console.log(privateVariable);
}

/* 公有变量和方法（可以访问私有变量和方法） */
return {
    publicMethod: function () {
        showPrivate();
    },
    publicVar: &apos;the public can see this!&apos;
};
};

var single = mySingleton();
single.publicMethod();  // 输出 &apos;something private&apos;
console.log(single.publicVar); // 输出 &apos;the public can see this!&apos;
</code></pre><p>为了节约资源的目的，我们可以另外一个构造函数里来初始化这些代码，如下：</p>
<pre><code>var Singleton = (function () {
var instantiated;
function init() {
    /*这里定义单例代码*/
    return {
        publicMethod: function () {
            console.log(&apos;hello world&apos;);
        },
        publicProperty: &apos;test&apos;
    };
}

return {
    getInstance: function () {
        if (!instantiated) {
            instantiated = init();
        }
        return instantiated;
    }
};
})();

/*调用公有的方法来获取实例:*/
Singleton.getInstance().publicMethod();
</code></pre><p>2.2 场景</p>
<p>单例一般是用在系统间各种模式的通信协调上，下面的代码是一个单例的最佳实践：</p>
<pre><code>var SingletonTester = (function () {

//参数：传递给单例的一个参数集合
function Singleton(args) {

    //设置args变量为接收的参数或者为空（如果没有提供的话）
    var args = args || {};
    //设置name参数
    this.name = &apos;SingletonTester&apos;;
    //设置pointX的值
    this.pointX = args.pointX || 6; //从接收的参数里获取，或者设置为默认值
    //设置pointY的值
    this.pointY = args.pointY || 10;

}

//实例容器
var instance;

var _static = {
    name: &apos;SingletonTester&apos;,

    //获取实例的方法
    //返回Singleton的实例
    getInstance: function (args) {
        if (instance === undefined) {
            instance = new Singleton(args);
        }
        return instance;
    }
};
return _static;
})();

var singletonTest = SingletonTester.getInstance({ pointX: 5 });
console.log(singletonTest.pointX); // 输出 5 
</code></pre><p>其他实现方式：</p>
<ul>
<li><p>方法1</p>
<pre><code>function Universe() {

// 判断是否存在实例
if (typeof Universe.instance === &apos;object&apos;) {
    return Universe.instance;
}

// 其它内容
this.start_time = 0;
this.bang = &quot;Big&quot;;

// 缓存
Universe.instance = this;

// 隐式返回this
}

// 测试
var uni = new Universe();
var uni2 = new Universe();
console.log(uni === uni2); // true
</code></pre></li>
<li><p>方法2</p>
<pre><code>function Universe() {

// 缓存的实例
var instance = this;

// 其它内容
this.start_time = 0;
this.bang = &quot;Big&quot;;

// 重写构造函数
Universe = function () {
    return instance;
};

}

// 测试
var uni = new Universe();
var uni2 = new Universe();
uni.bang = &quot;123&quot;;
console.log(uni === uni2); // true
console.log(uni2.bang); // 123
</code></pre></li>
<li><p>方法3</p>
<pre><code>function Universe() {

// 缓存实例
var instance;

// 重新构造函数
Universe = function Universe() {
    return instance;
};

// 后期处理原型属性
Universe.prototype = this;

// 实例
instance = new Universe();

// 重设构造函数指针
instance.constructor = Universe;

// 其它功能
instance.start_time = 0;
instance.bang = &quot;Big&quot;;

return instance;

}

    // 测试
    var uni = new Universe();
    var uni2 = new Universe();
    console.log(uni === uni2); // true

    // 添加原型属性
    Universe.prototype.nothing = true;

    var uni = new Universe();

    Universe.prototype.everything = true;

    var uni2 = new Universe();

    console.log(uni.nothing); // true
    console.log(uni2.nothing); // true
    console.log(uni.everything); // true
    console.log(uni2.everything); // true
    console.log(uni.constructor === Universe); // true
</code></pre></li>
<li><p>方法4</p>
<pre><code>var Universe;

(function () {

    var instance;

    Universe = function Universe() {

        if (instance) {
            return instance;
        }

        instance = this;

        // 其它内容
        this.start_time = 0;
        this.bang = &quot;Big&quot;;
    };
} ());

//测试代码
var a = new Universe();
var b = new Universe();
console.log(a === b); // true
a.bang = &quot;123&quot;;
console.log(b.bang); // 123
</code></pre></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/10/22/变量的解构赋值/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/22/变量的解构赋值/" itemprop="url">
                  变量的解构赋值
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-22T16:38:41+08:00">
              2018-10-22
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-10-22T18:21:23+08:00">
              2018-10-22
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/22/变量的解构赋值/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/22/变量的解构赋值/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.解构概念</strong></p>
<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值</strong>，这被称为解构（Destructuring）。</p>
<p><strong>2.数组的解构赋值</strong></p>
<p>2.1 基本用法</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code>let a = 1;
let b = 2;
let c = 3;
</code></pre><p>ES6 允许写成下面这样。</p>
<pre><code>let [a, b, c] = [1, 2, 3];
</code></pre><p><strong>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</strong> 下面是一些使用嵌套数组进行解构的例子。</p>
<pre><code>let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&apos;a&apos;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<pre><code>let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
</code></pre><p>2.2 默认值</p>
<p>解构赋值允许指定默认值。</p>
<pre><code>let [foo = true] = [];
foo // true

let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;
let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;
</code></pre><p><strong>3.对象解构</strong></p>
<p>解构不仅可以用于数组，还可以用于对象。</p>
<pre><code>let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
</code></pre><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code>let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined
</code></pre><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<p>这实际上说明，对象的解构赋值是下面形式的简写</p>
<pre><code>let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
</code></pre><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。<strong>真正被赋值的是后者，而不是前者。</strong></p>
<pre><code>let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p>
<p><strong>4.字符串的解构赋值</strong></p>
<pre><code>const [a, b, c, d, e] = &apos;hello&apos;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
</code></pre><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<pre><code>let {length : len} = &apos;hello&apos;;
len // 5
</code></pre><p><strong>5.数值和布尔值的解构赋值</strong></p>
<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<pre><code>let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
</code></pre><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<p><strong>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。</strong>由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<pre><code>let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
</code></pre><p><strong>6.函数参数的解构赋值</strong></p>
<p>函数的参数也可以使用解构赋值。</p>
<pre><code>function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
</code></pre><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<p>函数参数的解构也可以使用默认值。</p>
<pre><code>function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre><p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p>
<p><strong>7.用途</strong></p>
<ul>
<li><p>交换变量的值</p>
<pre><code>let x = 1;
let y = 2;
[x, y] = [y, x];
</code></pre><p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
</li>
<li><p>从函数返回多个值</p>
</li>
</ul>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<pre><code>// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
</code></pre><ul>
<li>函数参数的定义</li>
</ul>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code>// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
</code></pre><ul>
<li>提取 JSON 数据</li>
</ul>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<pre><code>let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre><p>上面代码可以快速提取 JSON 数据的值。</p>
<ul>
<li>函数参数的默认值</li>
</ul>
<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<pre><code>jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
</code></pre><ul>
<li>遍历 Map 结构</li>
</ul>
<p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code>const map = new Map();
map.set(&apos;first&apos;, &apos;hello&apos;);
map.set(&apos;second&apos;, &apos;world&apos;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
</code></pre><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code>// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
</code></pre><ul>
<li>输入模块的指定方法</li>
</ul>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<pre><code>const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/10/22/Proxy/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/22/Proxy/" itemprop="url">
                  ES6下Proxy(代理模式)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-22T16:22:45+08:00">
              2018-10-22
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-10-23T15:39:33+08:00">
              2018-10-23
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/22/Proxy/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/22/Proxy/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.概述</strong></p>
<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre><code>var obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`);
    return Reflect.set(target, key, value, receiver);
  }
});
</code></pre><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。</p>
<pre><code>obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
</code></pre><p>上面代码说明，Proxy <strong>实际上重载（overload）了点运算符</strong>，即用自己的定义覆盖了语言的原始定义(重写setter,getter方法)。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code>var proxy = new Proxy(target, handler);
</code></pre><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，<strong>new Proxy()表示生成一个Proxy实例</strong>，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<pre><code>var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35
</code></pre><p>上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。</p>
<p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p><strong>如果handler没有设置任何拦截，那就等同于直接通向原对象。</strong></p>
<pre><code>var target = {};
var handler = {};
var proxy = new Proxy(target, handler);
proxy.a = &apos;b&apos;;
target.a // &quot;b&quot;
</code></pre><p>上面代码中，handler是一个空对象，没有任何拦截效果，访问proxy就等同于访问target。</p>
<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<pre><code>var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
</code></pre><p>上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。</p>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li><p>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</p>
</li>
<li><p>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</p>
</li>
<li><p>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</p>
</li>
<li><p>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</p>
</li>
<li><p>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</p>
</li>
<li><p>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p>
</li>
<li><p>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p>
</li>
<li><p>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</p>
</li>
<li><p>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</p>
</li>
<li><p>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</p>
</li>
<li><p>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
</li>
<li><p>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p>
</li>
<li><p>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p>
</li>
</ul>
<p><strong>2.Proxy 实例的方法</strong></p>
<ul>
<li>get方法用于拦截某个属性的读取操作，可以接受三个参数，依次为<strong>目标对象、属性名和 proxy 实例本身</strong>（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</li>
</ul>
<p>get方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<p>var person = {<br>  name: “张三”<br>};</p>
<p>var proxy = new Proxy(person, {<br>  get: function(target, property) {<br>    if (property in target) {<br>      return target[property];<br>    } else {<br>      throw new ReferenceError(“Property \”” + property + “\” does not exist.”);<br>    }<br>  }<br>});</p>
<p>proxy.name // “张三”<br>proxy.age // 抛出一个错误</p>
<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。</p>
<ul>
<li>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为<strong>目标对象、属性名、属性值和 Proxy 实例本身</strong>，其中最后一个参数可选。</li>
</ul>
<p>假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。</p>
<pre><code>let validator = {
  set: function(obj, prop, value) {
    if (prop === &apos;age&apos;) {
      if (!Number.isInteger(value)) {
        throw new TypeError(&apos;The age is not an integer&apos;);
      }
      if (value &gt; 200) {
        throw new RangeError(&apos;The age seems invalid&apos;);
      }
    }

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  }
};

let person = new Proxy({}, validator);

person.age = 100;

person.age // 100
person.age = &apos;young&apos; // 报错
person.age = 300 // 报错
</code></pre><p>上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。</p>
<pre><code>const handler = {
  get (target, key) {
    invariant(key, &apos;get&apos;);
    return target[key];
  },
  set (target, key, value) {
    invariant(key, &apos;set&apos;);
    target[key] = value;
    return true;
  }
};
function invariant (key, action) {
  if (key[0] === &apos;_&apos;) {
    throw new Error(`Invalid attempt to ${action} private &quot;${key}&quot; property`);
  }
}
const target = {};
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private &quot;_prop&quot; property
proxy._prop = &apos;c&apos;
// Error: Invalid attempt to set private &quot;_prop&quot; property
</code></pre><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/10/19/js的垃圾回收机制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/10/19/js的垃圾回收机制/" itemprop="url">
                  js的垃圾回收机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-19T17:53:56+08:00">
              2018-10-19
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-10-23T10:37:13+08:00">
              2018-10-23
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/10/19/js的垃圾回收机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/10/19/js的垃圾回收机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.垃圾回收机制由来</strong></p>
<p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。为此系统提供相应的垃圾回收机制。</p>
<p><strong>2.方式</strong></p>
<p>现在各大浏览器通常用采用的垃圾回收有两种方法：<strong>标记清除</strong>、<strong>引用计数</strong>。</p>
<ul>
<li><p><strong>标记清除</strong></p>
<p>  这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p>
<p>  垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<p>  大部分浏览器都是使用这种方式进行垃圾回收，区别在于如何标记及垃圾回收间隔而已，而低版本IE采用的则是<strong>引用计数方式</strong>进行垃圾回收。</p>
</li>
<li><p><strong>引用计数</strong></p>
<p>  引用计数是一种不太常见的垃圾回收方式。</p>
<p>  引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p>
<p>  但这种方式很容易由于循环引用造成内存泄漏。比如对象A有一个属性指向对象B，而对象B也有有一个属性指向对象A，这样相互引用</p>
<pre><code>function test(){
    var objA={};
    var objB={};
    a.prop=b;
    b.prop=a;
}
</code></pre></li>
</ul>
<pre><code>这个例子中，objA和objB通过各自的属性相互引用，也就是说这两个对象的引用次数都是2。在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，objA和objB还将会继续存在，因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。      
</code></pre><p>   而在标记清除的策略下是没有问题的，离开环境的就被清除。</p>
<pre><code>我们知道，IE中有一部分对象并不是原生JavaScript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object 
</code></pre><p>Model，组件对象）对象的形式实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使IE的Javascript引擎使用标记清除的策略来实现的，但JavaScript访问的COM对象依然是基于引用计数的策略的。说白了，只要IE中涉及COM对象，就会存在循环引用的问题。看看下面的这个简单的例子：</p>
<pre><code>window.onload=function outerFunction(){
    var obj = document.getElementById(&quot;element&quot;);
    obj.onclick=function innerFunction(){};
};
</code></pre><p>上述例子obj引用了document.getElementById(“element”)，而document.getElementById(“element”)的onclick方法会引用外部环境中德变量，自然也包括obj。由于循环引用，也将会造成内存无法回收。</p>
<p>最简单的方式就是自己手工解除循环引用，如下</p>
<pre><code>window.onload=function outerFunction(){
    var obj = document.getElementById(&quot;element&quot;);
    obj.onclick=function innerFunction(){};
   obj=null;
};
</code></pre><p><strong>3.减少JavaScript中的垃圾回收</strong></p>
<p>首先，最明显的，new关键字就意味着一次内存分配，例如 new Foo()。最好的处理方法是：在初始化的时候新建对象，然后在后续过程中尽量多的重用这些创建好的对象。</p>
<p>另外还有以下三种内存分配表达式（可能不像new关键字那么明显了）：</p>
<ul>
<li><p>{} （创建一个新对象）</p>
</li>
<li><p>[] （创建一个新数组）</p>
</li>
<li><p>function() {…} (创建一个有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。新的方法，注意：新建方法也会导致垃圾收集！)</p>
</li>
</ul>
<p><strong>3.1 对象object优化</strong></p>
<p>为了最大限度的实现对象的重用，应该像避使用new语句一样避免使用{}来新建对象。</p>
<p>有一种方式能够保证对象（确保对象prototype上没有属性）的重复利用，那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。</p>
<p>cr.wipe(obj)方法就是为此功能而生，代码如下：</p>
<pre><code>// 删除obj对象的所有属性，高效的将obj转化为一个崭新的对象！
cr.wipe = function (obj) {
    for (var p in obj) {
         if (obj.hasOwnProperty(p))
            delete obj[p];
    }
};        
</code></pre><p>有些时候，你可以使用cr.wipe(obj)方法清理对象，再为obj添加新的属性，就可以达到重复利用对象的目的。虽然通过清空一个对象来获取“新对象”的做法，比简单的通过{}来创建对象要耗时一些，但是在实时性要求很高的代码中，这一点短暂的时间消耗，将会有效的减少垃圾堆积，并且最终避免垃圾回收暂停，这是非常值得的！</p>
<p><strong>3.2 数组array优化</strong></p>
<p>将[]赋值给一个数组对象，是清空数组的捷径（例如： arr = [];），但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</p>
<p><strong>3.3 方法function优化</strong></p>
<p> 方法一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。</p>
<p>在游戏的主循环中，setTimeout或requestAnimationFrame来调用一个成员方法是很常见的，例如：</p>
<pre><code>setTimeout(
    (function(self) {                    
      return function () { self.tick();}
    })(this), 16)
</code></pre><p>每过16毫秒调用一次this.tick()，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！为了解决这个问题，可以将作为返回值的方法保存起来，例如:</p>
<pre><code>// at startup
this.tickFunc = (
    function(self) {
      return function() {
                self.tick();
      };
    }
)(this);

// in the tick() function
setTimeout(this.tickFunc, 16);
</code></pre><p>相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/09/29/网络定位/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/29/网络定位/" itemprop="url">
                  定位简析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-29T15:17:05+08:00">
              2018-09-29
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-10-22T15:02:07+08:00">
              2018-10-22
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/09/29/网络定位/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/29/网络定位/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>定位方式</strong>:<br>定位分为<strong>GPS定位</strong>和<strong>网络定位</strong>2种。</p>
<p>GPS定位: 精度较高，可达到10米，但室内不可用，且超级费电。</p>
<p>网络定位: 分为wifi定位和基站定位，都是通过获取wifi或者基站信息，然后查询对应的wifi或者基站位置数据库，得到的定位地点。定位数据库可以不断完善不断补充，所以，越定位越准确。(常见的浏览器定位，IP定位也是网络定位)。</p>
<p><strong>HTML5地理定位</strong></p>
<p>目前前端采用的主流定位方式是基于H5所提供API进行定位。</p>
<p>H5 Geolocation API定位原理:<br>Geolocation API 是基于新增加的全局对象 navigator：<strong>navigator.geolocation</strong>。JavaScript 对象<br>navigator 包含了很有用的有关访问者的浏览器和系统的信息。<strong>Geolocation 可以使用 IP 地址、基于 Web 的数据库、无线网络连接和三角测量或 GPS 技术来确定经度和纬度。</strong></p>
<p>navigator.geolocation对象说明:</p>
<p><code>方法</code></p>
<ul>
<li><p>getCurrentPosition()</p>
<p>  navigator.geolocation.getCurrentPosition(geolocationSuccess,geolocationError,geolocationOptions);<br>  [geolocationSuccess]– 成功后的回调函数<br>  [geolocationError] – 失败后的回调函数<br>  [geolocationOptions] – 相关配置参数：</p>
<pre><code>enableHighAccuracy – 确保应用会给出最佳结果。
这有可能会让浏览器的反应时间变慢。如果是移动装置，还有可能因
为使用GPS而消耗更多电量。接受参数类型为boolean，默认为false。

timeout – 接受一个数字作为参数，默认为0微秒。设置浏览器的超时时间。 

maximumAge – 表示程序能接受的被缓存位置的最大过期时间。
接受一个数字作为参数，默认为0微秒。这就意味这默认每次获取位置都必需重新获取一个新位置。
</code></pre></li>
</ul>
<ul>
<li><p>watchPosition()<br> watchPosition()方法实现同getCurrentPosition()，区别在于getCurrentPosition() 方法能够获取用户的当前位置，但是只能获取一次。<br> watchPosition() 方法会定期查询用户的位置，观察用户位置是否发生了变化。所以基本上它一直在更新用户的位置。当你在移动的时候，这个功能会非常有利于追踪用户的位置。这个函数还会返回一个watchID值被clearWatch使用来停止监控。</p>
</li>
<li><p>clearWatch()</p>
<p> 这个方法接受一个参数，需要清理的观察进程的id：watchID（这个参数由watchPosition方法返回）。</p>
<pre><code>navigator.geolocation.clearWatch(watchID)
</code></pre></li>
</ul>
<p><code>属性</code></p>
<p>地理位置对象 Position</p>
<p>Geolocation API 的成功函数回调会返回一个地理位置对象 Position。这个对象具有两个属性：timestamp 和 coords。<strong>timestamp</strong> 属性表示地理数据创建的时间。而 <strong>coords</strong> 属性包含了 7 个属性：</p>
<ul>
<li>coords.latitude. 估算的纬度 </li>
<li>coords.longitude. 估算的经度</li>
<li>coords.altitude. 估算的高度 (以米为单位的海拔值) </li>
<li>coords.accuracy. 所得经度和纬度的估算精度，以米为单位 </li>
<li>coords.altitudeAccuracy. 所得高度的估算精度，以米为单位 </li>
<li>coords.heading. 宿主设备的当前移动方向，以度为单位，相对于正北方向顺时针方向计算</li>
<li>coords.speed. 设备的当前对地速度，以米/秒为单位</li>
</ul>
<p>这里只有 3 个属性是必需的：coords.latitude、coords.longitude 和 coords.accuracy。其他属性返回 null，取决于设备及其交互的后端定位服务器的功能。heading 和 speed 属性是基于用户的前一个位置计算的（如果有）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://www.skyshu.com/2018/09/29/promise/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="daydaybook">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="DDB Space">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="DDB Space" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/09/29/promise/" itemprop="url">
                  ES6中promise的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-29T15:15:23+08:00">
              2018-09-29
            </time>

            &nbsp;|&nbsp;

            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-check-o"></i>
            </span>
            <time title="Post modified" itemprop="dateModified" datetime="2018-11-14T15:01:25+08:00">
              2018-11-14
            </time>

          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/09/29/promise/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/09/29/promise/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.Promise 概念</strong></p>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p><strong>2.基本用法</strong></p>
<p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<pre><code>const promise = new Promise(function(resolve, reject) {
      // ... some code

      if (/* 异步操作成功 */){
        resolve(value);
      } else {
        reject(error);
      }
});
</code></pre><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>
<pre><code>promise.then(function(value) {
      // success
}, function(error) {
      // failure
});
</code></pre><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<p>举例用Promise对象实现的 Ajax 操作的例子。</p>
<pre><code>const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();
  });
  return promise;
};

getJSON(&quot;/posts.json&quot;).then(function(json) {
  console.log(&apos;Contents: &apos; + json);
}, function(error) {
  console.error(&apos;出错了&apos;, error);
});
</code></pre><p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p><strong>3.原型方法</strong></p>
<p><strong>3.1 Promise.prototype.then()</strong></p>
<p>Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。</p>
<p><strong>then方法返回的是一个新的Promise实例</strong>（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<pre><code>getJSON(&quot;/posts.json&quot;).then(function(json) {
  return json.post;
}).then(function(post) {
  // ...
});
</code></pre><p>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log(&quot;resolved: &quot;, comments);
}, function funcB(err){
  console.log(&quot;rejected: &quot;, err);
});
</code></pre><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</p>
<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>
<pre><code>getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;resolved: &quot;, comments),
  err =&gt; console.log(&quot;rejected: &quot;, err)
);
</code></pre><p><strong>3.2 Promise.prototype.catch()</strong></p>
<p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<pre><code>getJSON(&apos;/posts.json&apos;).then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&apos;发生错误！&apos;, error);
});
</code></pre><p>上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p>
<pre><code>p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .catch((err) =&gt; console.log(&apos;rejected&apos;, err));

// 等同于
p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre><p><strong>3.3 Promise.prototype.finally()</strong></p>
<p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的</p>
<pre><code>promise
.then(result =&gt; {···})
.catch(error =&gt; {···})
.finally(() =&gt; {···});
</code></pre><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。</p>
<pre><code>server.listen(port)
  .then(function () {
    // ...
  })
  .finally(server.stop);
</code></pre><p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>
<p>finally本质上是then方法的特例。</p>
<pre><code>promise
.finally(() =&gt; {
  // 语句
});

// 等同于
promise
.then(
  result =&gt; {
    // 语句
    return result;
  },
  error =&gt; {
    // 语句
    throw error;
  }
);
</code></pre><p>上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。</p>
<p>它的实现也很简单。</p>
<pre><code>Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};
</code></pre><p>上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。</p>
<p>从上面的实现还可以看到，finally方法总是会返回原来的值。</p>
<pre><code>// resolve 的值是 undefined
Promise.resolve(2).then(() =&gt; {}, () =&gt; {})

// resolve 的值是 2
Promise.resolve(2).finally(() =&gt; {})

// reject 的值是 undefined
Promise.reject(3).then(() =&gt; {}, () =&gt; {})

// reject 的值是 3
Promise.reject(3).finally(() =&gt; {})
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
    
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ww3.sinaimg.cn/small/005uY5V3gw1f9p51pmzakj3064064q2s.jpg"
               alt="daydaybook" />
          <p class="site-author-name" itemprop="name">daydaybook</p>
          <p class="site-description motion-element" itemprop="description">在小白的路上越走越远</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://weibo.com/" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.yinxiang.com/" title="印象笔记" target="_blank">印象笔记</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jianshu.com/" title="简书" target="_blank">简书</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">daydaybook</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"daydayhu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
